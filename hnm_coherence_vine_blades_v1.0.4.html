<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>HNM Coherence Vine Blades v1.0.4</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #1a1a1a; color: white; touch-action: none; font-family: Arial, sans-serif;}
        canvas { display: block; }
        #gui-container { position: absolute; top: 10px; right: 10px; z-index: 100;}
        #stats-container { position: absolute; top: 10px; left: 10px; z-index: 100;}
        #info { position: absolute; bottom: 10px; left: 10px; font-size: 10px; z-index: 100; background-color: rgba(0,0,0,0.7); padding: 6px; border-radius: 4px; max-width: calc(100% - 20px); line-height: 1.35; }
        #mobile-controls { position: fixed; bottom: 10px; left: 50%; transform: translateX(-50%); display: none; flex-direction: column; gap: 6px; z-index: 101; pointer-events: none; opacity:0; background-color: rgba(20,20,20,0.8); padding:8px; border-radius: 10px; }
        #mobile-controls .control-row { display: flex; gap: 6px; justify-content: center; }
        #mobile-controls button { padding: 8px 10px; font-size: 12px; background-color: rgba(100,100,100,0.7); border: 1px solid #bbb; color: white; border-radius: 6px; min-width:40px; text-align:center; font-weight: bold;}
        #bci-target-world-indicator { position: absolute; width: 12px; height: 12px; border: 2px solid yellow; background-color: rgba(255,255,0,0.3); border-radius: 50%; display: none; z-index: 150; transform: translate(-50%, -50%); pointer-events: none; opacity: 0.5;}
        #crosshair { position: fixed; left: 50%; top: 50%; width: 2px; height: 2px; background-color: white; border-radius: 50%; transform: translate(-50%, -50%); pointer-events: none; display: none; z-index: 200; }

        #health-bars { position: absolute; top: 50px; left: 10px; z-index: 100; background-color: rgba(0,0,0,0.5); padding: 5px; border-radius: 3px; font-size: 10px; }
        .health-bar { width: 100px; height: 10px; background-color: #555; border: 1px solid #777; margin-bottom: 3px; }
        .health-bar-inner { height: 100%; background-color: lightgreen; width: 100%; }
        .health-bar-inner.enemy { background-color: red; }

        @media (pointer: coarse) {
            #mobile-controls { display: flex; pointer-events: auto; opacity:1;}
            canvas { cursor: default; }
            #info {font-size: 8px;}
        }
    </style>
</head>
<body>
    <div id="gui-container"></div>
    <div id="stats-container"></div>
    <div id="info">
        HNM Player Vine/Blades - Combat Demo<br/>
        Loading...
    </div>
    <div id="mobile-controls">
        <div class="control-row">
            <button id="btn-cam-left" style="font-size:10px;">CamL</button>
            <button id="btn-forward">▲</button>
            <button id="btn-cam-right" style="font-size:10px;">CamR</button>
            <button id="btn-bci-target-toggle" style="font-size:10px;">BCIAim</button>
        </div>
        <div class="control-row">
            <button id="btn-left">◀</button>
            <button id="btn-backward">▼</button>
            <button id="btn-right">▶</button>
            <button id="btn-bci-action" style="font-size:10px;">BCIAct</button>
        </div>
         <div class="control-row">
            <button id="btn-jump">Jump</button>
            <button id="btn-deploy-blade" style="font-size:9px;">Dep.Bl</button>
            <button id="btn-direct-vine" style="font-size:9px;">Dir.Vin</button>
            <button id="btn-recall-blades" style="font-size:9px;">Rec.Bl</button>
        </div>
    </div>
    <div id="bci-target-world-indicator"></div>
    <div id="crosshair"></div>
    
    <div id="health-bars">
        <div>Player Health: <span id="player-health-value">100</span></div>
        <div class="health-bar" id="player-health-bar"><div class="health-bar-inner"></div></div>
        <div id="enemies-health-container"></div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.17.0/dist/tf.min.js"></script>
    <script type="text/javascript">
// hnm_core_v1.js
// --- Logging Utility (Adapted for Resonant Artifacts context) ---
function hnmLog(message, level = "info") {
    console[level](`[HNM] ${message}`);
}

// --- TensorFlow.js dependent HNM Components ---

class MemoryMLP_TFJS {
    constructor(inputDim, depth, expansionOrTargetDim, namePrefix = '', activation = 'elu') {
        this.inputDim = inputDim;
        this.depth = depth;
        this.namePrefix = namePrefix;
        this.model = null;
        this.isDisposed = false;

        if (depth < 1) { this.isIdentity = true; return; }
        this.isIdentity = false;

        const layers = [];
        let currentLayerInputShape = [this.inputDim];

        for (let i = 0; i < depth; i++) {
            const isLast = i === (depth - 1);
            let currentLayerOutputUnits;

            if (depth === 1) { currentLayerOutputUnits = expansionOrTargetDim; }
            else { currentLayerOutputUnits = isLast ? this.inputDim : Math.floor(this.inputDim * expansionOrTargetDim); }

            const denseLayerConfig = {
                units: currentLayerOutputUnits, kernelInitializer: 'glorotUniform',
                biasInitializer: 'zeros', name: `${namePrefix}_mlp_dense_${i}`
            };
            if (i === 0) { denseLayerConfig.inputShape = currentLayerInputShape; }
            layers.push(tf.layers.dense(denseLayerConfig));
            currentLayerInputShape = [currentLayerOutputUnits];

            if (!isLast) { layers.push(tf.layers.activation({activation: activation, name: `${namePrefix}_mlp_act_${i}`})); }
        }
        this.model = tf.sequential({ name: `${namePrefix}_mlp_sequential`, layers });
    }

    call(inputs) {
        if (this.isDisposed) throw new Error(`${this.namePrefix} MLP model is disposed.`);
        if (this.isIdentity) return tf.keep(inputs.clone());
        if (!this.model) throw new Error (`MemoryMLP_TFJS (${this.namePrefix}): Model not initialized properly.`);
        return this.model.apply(inputs);
    }

    getWeights() {
        if (this.isDisposed || this.isIdentity || !this.model) return [];
        return this.model.getWeights().map(w => tf.keep(w.clone()));
    }

    setWeights(weights) {
        if (this.isDisposed || this.isIdentity || !this.model || !weights || weights.length === 0) return;
        this.model.setWeights(weights);
    }

    getTrainableVariables() {
        if (this.isDisposed || this.isIdentity || !this.model) return [];
        return this.model.trainableWeights.map(tw => tw.val);
    }

    dispose() {
        if (this.isDisposed) return;
        if (this.model && typeof this.model.dispose === 'function') { this.model.dispose(); }
        this.model = null; this.isDisposed = true;
    }
}

function createNeuralMemState(seq_index = 0, layerWeights = {}, optim_state = {}) {
    return { seq_index, layerWeights, optim_state };
}

function memStateDetach(state) {
    if (!state) return null;
    const detachedLayerWeights = {};
    for (const key in state.layerWeights) {
        if (Array.isArray(state.layerWeights[key])) {
            detachedLayerWeights[key] = state.layerWeights[key].map(t => {
                if (t && !t.isDisposed) return tf.keep(t.clone());
                hnmLog(`Warning: memStateDetach found disposed or null tensor for weight key ${key}. Returning null for this tensor.`, "warn");
                return null;
            }).filter(t => t !== null);
        } else {
            hnmLog(`Warning: memStateDetach encountered non-array weights for key ${key}`, "warn");
            detachedLayerWeights[key] = [];
        }
    }
    const detachedOptimState = JSON.parse(JSON.stringify(state.optim_state || {}));
    return createNeuralMemState(state.seq_index, detachedLayerWeights, detachedOptimState);
}

function disposeMemStateWeights(state) {
    if (state && state.layerWeights) {
        for (const key in state.layerWeights) {
            if (Array.isArray(state.layerWeights[key])) {
                state.layerWeights[key].forEach(t => { if (t && !t.isDisposed) t.dispose(); });
            }
        }
        state.layerWeights = {};
    }
}

function disposeHnsResultsTensors(hnsResults) {
    if (!hnsResults) return;
    const tensorDictionaries = [
        hnsResults.anomalies,
        hnsResults.weightChanges,
        hnsResults.buNorms,
        hnsResults.tdNorms,
        hnsResults.extNorms
    ];
    tensorDictionaries.forEach(dict => {
        if (dict) {
            Object.values(dict).forEach(tensor => {
                if (tensor && !tensor.isDisposed && typeof tensor.dispose === 'function') {
                    tensor.dispose();
                }
            });
        }
    });
}


class NMM_TD_V5_TFJS {
    constructor(config) {
        this.levelName = config.name; this.dim = config.dim;
        this.buInputDims = { ...(config.bu_input_dims || {}) };
        this.tdInputDims = { ...(config.td_input_dims || {}) };

        this.nmmParams = {
            mem_model_depth: 2,
            mem_model_expansion: 2.0,
            learning_rate: 0.000, // Effectively no training for this integration by default
            weight_decay: 0.000,  // No decay
            beta1: 0.9,
            beta2: 0.999,
            max_grad_norm: 1.0,
            external_signal_dim: config.nmm_params?.external_signal_dim || 0,
            external_signal_role: config.nmm_params?.external_signal_role || 'none',
            verbose: config.nmm_params?.verbose || false,
            ...(config.nmm_params || {}) // Allow overrides
        };
        if (this.nmmParams.learning_rate === 0) {
             if(this.nmmParams.verbose) hnmLog(`NMM_TD_V5_TFJS (${this.levelName}): LR is 0, training ops will be skipped.`);
        }

        this.memoryModel = new MemoryMLP_TFJS(
            this.dim,
            this.nmmParams.mem_model_depth,
            (this.nmmParams.mem_model_depth === 1) ? this.dim : this.nmmParams.mem_model_expansion,
            `${this.levelName}_mem_mlp`
        );
        this.toValueTarget = new MemoryMLP_TFJS(this.dim, 1, this.dim, `${this.levelName}_val_proj`);

        this.buProjections = {};
        for (const name in this.buInputDims) { this.buProjections[name] = new MemoryMLP_TFJS(this.buInputDims[name], 1, this.dim, `${this.levelName}_bu_proj_${name}`); }
        this.tdProjections = {};
        for (const name in this.tdInputDims) { this.tdProjections[name] = new MemoryMLP_TFJS(this.tdInputDims[name], 1, this.dim, `${this.levelName}_td_proj_${name}`); }

        this.externalSignalProjection = null;
        if (this.nmmParams.external_signal_dim > 0 && this.nmmParams.external_signal_role !== 'none') {
            this.externalSignalProjection = new MemoryMLP_TFJS(this.nmmParams.external_signal_dim, 1, this.dim, `${this.levelName}_ext_proj`);
        }

        this.lossFn = (labels, predictions) => tf.losses.meanSquaredError(labels, predictions);
        if (this.nmmParams.learning_rate > 0) {
            this.optimizer = tf.train.adam(this.nmmParams.learning_rate, this.nmmParams.beta1, this.nmmParams.beta2, 1e-7);
        } else {
            this.optimizer = null; // No optimizer if not learning
        }
        if(this.nmmParams.verbose) hnmLog(`NMM_TD_V5_TFJS (${this.levelName}): Dim=${this.dim}, ExtDim=${this.nmmParams.external_signal_dim}, Role=${this.nmmParams.external_signal_role}, LR=${this.nmmParams.learning_rate.toExponential(2)}`);
        this.isDisposed = false;
    }

    _getLayerWeights() {
        if (this.isDisposed) throw new Error(`${this.levelName} NMM is disposed.`);
        const weights = { memoryModel: this.memoryModel.getWeights(), toValueTarget: this.toValueTarget.getWeights() };
        for (const name in this.buProjections) { weights[`buProj_${name}`] = this.buProjections[name].getWeights(); }
        for (const name in this.tdProjections) { weights[`tdProj_${name}`] = this.tdProjections[name].getWeights(); }
        if (this.externalSignalProjection) { weights.externalSignalProjection = this.externalSignalProjection.getWeights(); }
        return weights;
    }

    _applyLayerWeights(layerWeights) {
        if (this.isDisposed) throw new Error(`${this.levelName} NMM is disposed.`);
        if (!layerWeights) return;

        const tempClonedWeights = {};
        for (const key in layerWeights) {
            if (Array.isArray(layerWeights[key])) {
                tempClonedWeights[key] = layerWeights[key].map(t => t && !t.isDisposed ? t.clone() : null).filter(t => t);
            }
        }

        this.memoryModel.setWeights(tempClonedWeights.memoryModel || []);
        this.toValueTarget.setWeights(tempClonedWeights.toValueTarget || []);
        for (const name in this.buProjections) { this.buProjections[name].setWeights(tempClonedWeights[`buProj_${name}`] || []); }
        for (const name in this.tdProjections) { this.tdProjections[name].setWeights(tempClonedWeights[`tdProj_${name}`] || []); }
        if (this.externalSignalProjection && tempClonedWeights.externalSignalProjection) { this.externalSignalProjection.setWeights(tempClonedWeights.externalSignalProjection || []); }

        for (const key in tempClonedWeights) {
            if (Array.isArray(tempClonedWeights[key])) {
                tempClonedWeights[key].forEach(t => { if (t && !t.isDisposed) t.dispose(); });
            }
        }
    }

    getInitialState() {
        if (this.isDisposed) throw new Error(`${this.levelName} NMM is disposed.`);
        return createNeuralMemState(0, this._getLayerWeights(), { lr: this.nmmParams.learning_rate, wd: this.nmmParams.weight_decay });
    }

   _calculateWeightChange(oldWeightsMap, newWeightsMap) {
        return tf.tidy(`${this.levelName}_WeightChange`,() => {
            if (this.nmmParams.learning_rate === 0) return tf.keep(tf.tensor(0.0)); // No change if not learning

            let totalDiffSqSum = tf.tensor(0.0);
             for (const key in newWeightsMap) {
                 const oldWArray = oldWeightsMap[key]; const newWArray = newWeightsMap[key];
                 if (oldWArray && newWArray && oldWArray.length === newWArray.length) {
                     for (let i = 0; i < newWArray.length; i++) {
                         const oldW = oldWArray[i]; const newW = newWArray[i];
                         if (oldW && newW && !oldW.isDisposed && !newW.isDisposed && oldW.shape.toString() === newW.shape.toString()) {
                             const diff = newW.sub(oldW);
                             totalDiffSqSum = totalDiffSqSum.add(diff.square().sum());
                             diff.dispose();
                         } else { if(this.nmmParams.verbose) hnmLog(`Warning: Tensor mismatch or disposal during weight change calc for ${key}[${i}]`, "warn"); }
                     }
                 }
             }
            return tf.keep(totalDiffSqSum.sqrt());
        });
    }


    forwardStep(buInputs, tdSignals, currentState, externalSignal = null, detachNextState = true) {
        if (this.isDisposed) throw new Error(`${this.levelName} NMM is disposed.`);

        const oldWeightsForChangeCalc = (this.nmmParams.learning_rate > 0) ? this._getLayerWeights() : null;
        this._applyLayerWeights(currentState.layerWeights);

        const resultsTidy = tf.tidy(`${this.levelName}_NMM_ForwardStep`, () => {
            const preparedInputs = tf.tidy(`${this.levelName}_InputPrep`, () => {
                const projectedBuSignals = [];
                for (const name in buInputs) {
                    if (this.buProjections[name] && buInputs[name] && !buInputs[name].isDisposed && buInputs[name].shape) {
                        projectedBuSignals.push(this.buProjections[name].call(buInputs[name].reshape([-1, this.buInputDims[name]])));
                    } else {
                        if(this.nmmParams.verbose) hnmLog(`Warning: Skipping BU input for ${name} in ${this.levelName}. Using zeros.`, "warn");
                        projectedBuSignals.push(tf.zeros([1, this.dim]));
                    }
                }
                const combBu = projectedBuSignals.length > 0 ? tf.addN(projectedBuSignals) : tf.zeros([1, this.dim]);
                projectedBuSignals.forEach(t => {if (t && !t.isDisposed) t.dispose(); });
                const cBuNorm = tf.norm(combBu);

                const projectedTdSignals = [];
                for (const name in tdSignals) {
                    if (this.tdProjections[name] && tdSignals[name] && !tdSignals[name].isDisposed && tdSignals[name].shape) {
                        projectedTdSignals.push(this.tdProjections[name].call(tdSignals[name].reshape([-1, this.tdInputDims[name]])));
                    } else {
                       if(this.nmmParams.verbose) hnmLog(`Warning: Skipping TD input for ${name} in ${this.levelName}. Using zeros.`, "warn");
                       projectedTdSignals.push(tf.zeros([1, this.dim]));
                    }
                }
                const combTd = projectedTdSignals.length > 0 ? tf.addN(projectedTdSignals) : tf.zeros([1, this.dim]);
                projectedTdSignals.forEach(t => {if (t && !t.isDisposed) t.dispose(); });
                const cTdNorm = tf.norm(combTd);

                let projExtSig = null;
                let cExtNorm = tf.tensor(0.0);
                if (this.nmmParams.external_signal_role !== 'none' && this.externalSignalProjection) {
                    if (externalSignal && !externalSignal.isDisposed && externalSignal.shape && externalSignal.shape.length === 3 && externalSignal.shape[externalSignal.shape.length -1] === this.nmmParams.external_signal_dim) {
                       projExtSig = this.externalSignalProjection.call(externalSignal.reshape([-1, this.nmmParams.external_signal_dim]));
                    } else {
                        if(this.nmmParams.verbose && externalSignal) hnmLog(`Warning: External signal for ${this.levelName} invalid. Using zeros. Expected dim ${this.nmmParams.external_signal_dim}, got shape ${externalSignal?.shape}`, "warn");
                        else if (this.nmmParams.verbose && !externalSignal && this.nmmParams.external_signal_dim > 0) hnmLog(`Warning: External signal for ${this.levelName} missing. Using zeros. Expected dim ${this.nmmParams.external_signal_dim}`, "warn");
                        projExtSig = tf.zeros([1, this.dim]);
                    }
                    cExtNorm.dispose();
                    cExtNorm = tf.norm(projExtSig);
                }

                let keyBaseForPredictionTarget = combBu.clone();
                if (this.nmmParams.external_signal_role === 'add_to_bu' && projExtSig) {
                    keyBaseForPredictionTarget = keyBaseForPredictionTarget.add(projExtSig);
                }

                let mInput = combBu.add(combTd);
                if (this.nmmParams.external_signal_role === 'add_to_bu' && projExtSig) {
                    mInput = mInput.add(projExtSig);
                } else if (this.nmmParams.external_signal_role === 'add_to_td' && projExtSig) {
                    mInput = mInput.add(projExtSig);
                }

                let fValTarget = this.toValueTarget.call(keyBaseForPredictionTarget);
                if (this.nmmParams.external_signal_role === 'add_to_target' && projExtSig) {
                    fValTarget = fValTarget.add(projExtSig);
                }
                if (projExtSig && projExtSig !== externalSignal && !projExtSig.isDisposed && projExtSig.rank > 0) projExtSig.dispose();

                return { memInput: mInput, finalValTarget: fValTarget, currentBuNorm: cBuNorm, currentTdNorm: cTdNorm, currentExtNorm: cExtNorm };
            });

            const keptBuNorm = tf.keep(preparedInputs.currentBuNorm);
            const keptTdNorm = tf.keep(preparedInputs.currentTdNorm);
            const keptExtNorm = tf.keep(preparedInputs.currentExtNorm);

            const predictionBeforeTrain = this.memoryModel.call(preparedInputs.memInput);
            const keptPredictionForOutput = tf.keep(predictionBeforeTrain.clone().reshape([1, 1, this.dim]));

            let currentLossTensor = tf.tensor(0.0);

            if (this.optimizer && this.nmmParams.learning_rate > 0) {
                const trainableVarsForOptimizer = [];
                this.memoryModel.getTrainableVariables().forEach(v => trainableVarsForOptimizer.push(v));
                if (this.externalSignalProjection && this.nmmParams.external_signal_role !== 'none' && this.nmmParams.external_signal_dim > 0) {
                     this.externalSignalProjection.getTrainableVariables().forEach(v => trainableVarsForOptimizer.push(v));
                }

                if (trainableVarsForOptimizer.length > 0) {
                    const calculateLossFn = () => {
                        const currentPred = this.memoryModel.call(preparedInputs.memInput);
                        let mseLoss = this.lossFn(preparedInputs.finalValTarget, currentPred);
                        if (this.nmmParams.weight_decay > 0) {
                            let l2Loss = tf.tensor(0.0);
                            trainableVarsForOptimizer.forEach(v => { if (v.name.includes('kernel')) { l2Loss = l2Loss.add(v.square().sum()); } });
                            mseLoss = mseLoss.add(l2Loss.mul(this.nmmParams.weight_decay / 2));
                            l2Loss.dispose();
                        }
                        return mseLoss;
                    };

                    if (this.nmmParams.max_grad_norm && this.nmmParams.max_grad_norm > 0) {
                        const {value, grads} = this.optimizer.computeGradients(calculateLossFn, trainableVarsForOptimizer);
                        currentLossTensor.dispose(); currentLossTensor = value ? tf.keep(value) : tf.keep(tf.tensor(0.0));
                         if (grads) {
                            const gradArray = trainableVarsForOptimizer.map(v => grads[v.name]).filter(g => g && !g.isDisposed);
                            let finalGradsForApply = {};
                            if (gradArray.length > 0) {
                                const globalNorm = tf.tidy('globalNormCalc', () => { let totalNormSq = tf.scalar(0.0); for (const grad of gradArray) { totalNormSq = totalNormSq.add(tf.norm(grad).square()); } return totalNormSq.sqrt(); });
                                const globalNormVal = globalNorm.dataSync()[0]; globalNorm.dispose();
                                let clipRatioScalar = null; if (globalNormVal > this.nmmParams.max_grad_norm) { clipRatioScalar = tf.scalar(this.nmmParams.max_grad_norm / (globalNormVal + 1e-6)); }
                                trainableVarsForOptimizer.forEach(v => { if (grads[v.name] && !grads[v.name].isDisposed) { finalGradsForApply[v.name] = clipRatioScalar ? grads[v.name].mul(clipRatioScalar) : grads[v.name].clone(); } });
                                if (clipRatioScalar) clipRatioScalar.dispose();
                            }
                            this.optimizer.applyGradients(finalGradsForApply);
                            trainableVarsForOptimizer.forEach(v => { if (grads[v.name] && !grads[v.name].isDisposed) grads[v.name].dispose(); });
                            Object.values(finalGradsForApply).forEach(g => {if (g && !g.isDisposed) g.dispose(); });
                         } else { if(this.nmmParams.verbose) hnmLog(`Warning: Grads object from computeGradients is null/undefined for NMM ${this.levelName}.`, "warn");}
                    } else {
                        const lossTensorFromOptimizer = this.optimizer.minimize(calculateLossFn, true, trainableVarsForOptimizer);
                        currentLossTensor.dispose(); currentLossTensor = lossTensorFromOptimizer ? tf.keep(lossTensorFromOptimizer) : tf.keep(tf.tensor(0.0));
                    }
                } else { if(this.nmmParams.verbose) hnmLog(`Warning: No trainable variables for NMM ${this.levelName}. Training skipped.`, "warn"); }
            } else {
                currentLossTensor.dispose();
                currentLossTensor = tf.keep(this.lossFn(predictionBeforeTrain, preparedInputs.finalValTarget));
            }
            if (preparedInputs.memInput && !preparedInputs.memInput.isDisposed) preparedInputs.memInput.dispose();
            if (preparedInputs.finalValTarget && !preparedInputs.finalValTarget.isDisposed) preparedInputs.finalValTarget.dispose();

            return { prediction: keptPredictionForOutput, loss: currentLossTensor, buNorm: keptBuNorm, tdNorm: keptTdNorm, extNorm: keptExtNorm };
        });

        const retrievedValForOutput = resultsTidy.prediction;
        const lossVal = resultsTidy.loss;
        const buNormVal = resultsTidy.buNorm;
        const tdNormVal = resultsTidy.tdNorm;
        const extNormVal = resultsTidy.extNorm;

        let weightChangeVal;
        let newModelWeightsAfterTraining;
        if (this.nmmParams.learning_rate > 0 && oldWeightsForChangeCalc) {
            newModelWeightsAfterTraining = this._getLayerWeights();
            weightChangeVal = this._calculateWeightChange(oldWeightsForChangeCalc, newModelWeightsAfterTraining);
            Object.values(oldWeightsForChangeCalc).forEach(arr => arr.forEach(t => { if (t && !t.isDisposed) t.dispose(); }));
        } else {
            weightChangeVal = tf.keep(tf.tensor(0.0));
            newModelWeightsAfterTraining = currentState.layerWeights;
        }


        const nextStateInterim = createNeuralMemState(currentState.seq_index + 1, newModelWeightsAfterTraining, currentState.optim_state);
        const nextStateFinal = detachNextState ? memStateDetach(nextStateInterim) : nextStateInterim;
        if (detachNextState && this.nmmParams.learning_rate > 0 && newModelWeightsAfterTraining !== currentState.layerWeights) {
             disposeMemStateWeights(nextStateInterim);
        } else if (detachNextState && this.nmmParams.learning_rate === 0) {
            // No disposal needed here if not training, as memStateDetach clones.
        }


        return { retrievedVal: retrievedValForOutput, nextState: nextStateFinal, anomalyScore: lossVal, weightChange: weightChangeVal, buNorm: buNormVal, tdNorm: tdNormVal, extNorm: extNormVal };
    }

    dispose() {
        if (this.isDisposed) return;
        this.memoryModel.dispose(); this.toValueTarget.dispose();
        Object.values(this.buProjections).forEach(p => p.dispose()); Object.values(this.tdProjections).forEach(p => p.dispose());
        if(this.externalSignalProjection) this.externalSignalProjection.dispose();
        this.isDisposed = true; hnmLog(`NMM ${this.levelName} disposed.`);
    }
}


class HierarchicalSystemV5_TFJS {
    constructor(levelConfigsHLC, globalSimConfig) {
        this.levelConfigsOriginal = JSON.parse(JSON.stringify(levelConfigsHLC));
        this.globalConfig = globalSimConfig;
        this.numLevels = 0; this.levels = [];
        this.levelNameToIndex = {}; this.dims = {}; this.isDisposed = false;
        this.level_expected_external_details = [];

        this._initializeLevels();
    }

    _initializeLevels() {
        hnmLog(`HS_V5_TFJS: Initializing ${this.levelConfigsOriginal.length} levels.`);
        this.levelConfigsOriginal.forEach((cfg, i) => {
            if (!cfg.name || !cfg.dim) throw new Error(`Level ${i} config missing name or dim.`);
            this.levelNameToIndex[cfg.name] = i; this.dims[cfg.name] = cfg.dim;
        });

        this.levelConfigsOriginal.forEach((hlc_level_cfg, i) => {
            const nmmConstructorConfig = {
                name: hlc_level_cfg.name,
                dim: hlc_level_cfg.dim,
                bu_input_dims: {},
                td_input_dims: {},
                nmm_params: {
                    verbose: this.globalConfig.HNM_VERBOSE || false,
                    learning_rate: 0.000, // Defaulting to no learning for this integration
                    weight_decay: 0.000,
                    beta1: 0.9, beta2: 0.999, max_grad_norm: 1.0,
                    external_signal_dim: 0, external_signal_role: 'none',
                    mem_model_depth: 2, mem_model_expansion: 2.0,
                    ...(hlc_level_cfg.nmm_params || {})
                }
            };

            if (!hlc_level_cfg.bu_source_level_names || hlc_level_cfg.bu_source_level_names.length === 0) {
                if (!hlc_level_cfg.raw_sensory_input_dim || hlc_level_cfg.raw_sensory_input_dim <= 0) {
                    throw new Error(`Lvl '${hlc_level_cfg.name}' is a sensory level but lacks a valid 'raw_sensory_input_dim'.`);
                }
                nmmConstructorConfig.bu_input_dims[hlc_level_cfg.name] = hlc_level_cfg.raw_sensory_input_dim;
            } else {
                hlc_level_cfg.bu_source_level_names.forEach(srcName => {
                    if (!this.dims[srcName]) throw new Error(`Unknown BU source '${srcName}' for level '${hlc_level_cfg.name}'.`);
                    nmmConstructorConfig.bu_input_dims[srcName] = this.dims[srcName];
                });
            }
            if (hlc_level_cfg.td_source_level_names) {
                 hlc_level_cfg.td_source_level_names.forEach(srcName => {
                    if (!this.dims[srcName]) throw new Error(`Unknown TD source '${srcName}' for level '${hlc_level_cfg.name}'.`);
                    nmmConstructorConfig.td_input_dims[srcName] = this.dims[srcName];
                });
            }

            let expectedNmmExtSourceName = null;
            let nmmExtSignalDimForNMM = 0;
            let nmmExtSignalRoleForNMM = nmmConstructorConfig.nmm_params.external_signal_role;

            const specificExtConfig = hlc_level_cfg.external_input_config;
            if (specificExtConfig && typeof specificExtConfig === 'object' && !Array.isArray(specificExtConfig) &&
                specificExtConfig.source_signal_name && specificExtConfig.dim > 0) {

                expectedNmmExtSourceName = specificExtConfig.source_signal_name;
                nmmExtSignalDimForNMM = specificExtConfig.dim;

                if (specificExtConfig.role) { // Role from external_input_config overrides nmm_params for this signal
                    nmmExtSignalRoleForNMM = specificExtConfig.role;
                } else if (nmmExtSignalDimForNMM > 0 && nmmExtSignalRoleForNMM === 'none') {
                    nmmExtSignalRoleForNMM = 'add_to_bu'; // Default if dim provided but no role
                }
            } else if (specificExtConfig && nmmConstructorConfig.nmm_params.verbose) {
                hnmLog(`Warning for ${hlc_level_cfg.name}: external_input_config is present but invalid or incomplete. ${JSON.stringify(specificExtConfig)}`, "warn");
            }

            nmmConstructorConfig.nmm_params.external_signal_dim = nmmExtSignalDimForNMM;
            nmmConstructorConfig.nmm_params.external_signal_role = nmmExtSignalRoleForNMM;
            this.level_expected_external_details[i] = { name: expectedNmmExtSourceName, dim: nmmExtSignalDimForNMM };

            this.levels.push(new NMM_TD_V5_TFJS(nmmConstructorConfig));
        });
        this.numLevels = this.levels.length;
        hnmLog(`HS_V5_TFJS: Initialization complete. ${this.levels.length} levels created.`);
    }

    getInitialStates() {
        if (this.isDisposed) throw new Error(`HNS is disposed.`);
        return this.levels.map(level => level.getInitialState());
    }

    step(currentBotLevelStates, currentBotLastStepOutputs, sensoryInputs, externalInputsAllSources = {}, detachNextStatesMemory = true) {
        if (this.isDisposed) throw new Error(`HNS is disposed.`);

        const nextBotLevelStatesList = new Array(this.numLevels).fill(null);
        const newlyRetrievedValuesForAllLevelsDict = {};
        const stepAnomalies = {}; const stepWeightChanges = {};
        const stepBuNorms = {}; const stepTdNorms = {}; const stepExternalNorms = {};
        const currentStepIntermediateOutputs = {};

        for (let i = 0; i < this.numLevels; i++) {
            const lvlMgr = this.levels[i]; const cfg = this.levelConfigsOriginal[i];
            const lvlName = cfg.name; const buSrcNames = cfg.bu_source_level_names || []; const tdSrcNames = cfg.td_source_level_names || [];
            const currentLevelSpecificState = currentBotLevelStates[i];
            const lvlBuIn = {}; const lvlTdIn = {};

            if (buSrcNames.length === 0) { // This is a root sensory level
                const rawSensoryDim = cfg.raw_sensory_input_dim; // The dim this level expects for its raw sensory input
                const sensoryInputTensor = sensoryInputs[lvlName]; // Get the tensor for this specific level

                if (sensoryInputTensor && !sensoryInputTensor.isDisposed &&
                    sensoryInputTensor.shape && sensoryInputTensor.shape.length === 3 && // Expect [1,1,dim]
                    sensoryInputTensor.shape[0] === 1 && sensoryInputTensor.shape[1] === 1 &&
                    sensoryInputTensor.shape[2] === rawSensoryDim) {
                    lvlBuIn[lvlName] = sensoryInputTensor; // Keyed by its own name for sensory input
                } else {
                    if(lvlMgr.nmmParams.verbose) hnmLog(`Warning: Sensory input for ${lvlName} is invalid or missing. Using zeros. Expected shape [1,1,${rawSensoryDim}], got ${sensoryInputTensor?.shape}`, "warn");
                    lvlBuIn[lvlName] = tf.keep(tf.zeros([1, 1, rawSensoryDim]));
                }
            } else { // This level gets BU input from other levels' current step outputs
                buSrcNames.forEach(srcName => {
                    const buSourceOutput = currentStepIntermediateOutputs[srcName]; // Output from a previous level *in this same step*
                    if (buSourceOutput && !buSourceOutput.isDisposed) { lvlBuIn[srcName] = buSourceOutput; }
                    else {
                        hnmLog(`Warning: Missing BU source output from '${srcName}' for level '${lvlName}' in current step. Using zeros.`, "warn");
                        lvlBuIn[srcName] = tf.keep(tf.zeros([1, 1, this.dims[srcName]]));
                    }
                });
            }

            // TD inputs come from *last* step's outputs of higher levels
            tdSrcNames.forEach(srcName => {
                const tdSourceOutput = currentBotLastStepOutputs[srcName]?.retrievedVal; // From HNM's previous full pass
                if (tdSourceOutput && !tdSourceOutput.isDisposed) { lvlTdIn[srcName] = tdSourceOutput; }
                else { // If TD signal is missing, provide zeros
                    lvlTdIn[srcName] = tf.keep(tf.zeros([1, 1, this.dims[srcName]]));
                }
            });

            // External input for this specific NMM
            let lvlExtInForNMMStep = null;
            const expectedExternal = this.level_expected_external_details[i]; // {name, dim} this NMM expects
            if (expectedExternal && expectedExternal.name && expectedExternal.dim > 0) {
                const providedSignal = externalInputsAllSources[expectedExternal.name];
                if (providedSignal && !providedSignal.isDisposed && providedSignal.shape &&
                    providedSignal.shape.length === 3 && providedSignal.shape[0] === 1 &&
                    providedSignal.shape[1] === 1 && providedSignal.shape[2] === expectedExternal.dim) {
                    lvlExtInForNMMStep = providedSignal;
                } else {
                    if(lvlMgr.nmmParams.verbose) hnmLog(`Warning for ${lvlName}: External signal '${expectedExternal.name}' invalid or missing from externalInputsAllSources. Using zeros. Expected dim ${expectedExternal.dim}, got ${providedSignal?.shape}`, "warn");
                    lvlExtInForNMMStep = tf.keep(tf.zeros([1,1,expectedExternal.dim]));
                }
            }

            const nmmOutputs = lvlMgr.forwardStep(lvlBuIn, lvlTdIn, currentLevelSpecificState, lvlExtInForNMMStep, detachNextStatesMemory);

            nextBotLevelStatesList[i] = nmmOutputs.nextState;
            currentStepIntermediateOutputs[lvlName] = tf.keep(nmmOutputs.retrievedVal.clone()); // This level's output for current step
            newlyRetrievedValuesForAllLevelsDict[lvlName] = nmmOutputs.retrievedVal; // For the final HNS output dict

            stepAnomalies[lvlName] = nmmOutputs.anomalyScore;
            stepWeightChanges[lvlName] = nmmOutputs.weightChange;
            stepBuNorms[lvlName] = nmmOutputs.buNorm;
            stepTdNorms[lvlName] = nmmOutputs.tdNorm;
            stepExternalNorms[lvlName] = nmmOutputs.extNorm;

            Object.entries(lvlBuIn).forEach(([key, t]) => { if (t !== sensoryInputs[lvlName] && t !== currentStepIntermediateOutputs[key] && t.rank === 3 && t.shape[0] === 1 && !t.isDisposed && t.dataSync().every(v => v ===0) ) t.dispose(); });
            Object.entries(lvlTdIn).forEach(([key, t]) => { if (t !== currentBotLastStepOutputs[key]?.retrievedVal && t.rank === 3 && t.shape[0] === 1 && !t.isDisposed && t.dataSync().every(v => v ===0) ) t.dispose(); });
            if (lvlExtInForNMMStep && lvlExtInForNMMStep !== externalInputsAllSources[expectedExternal?.name] && lvlExtInForNMMStep.rank === 3 && lvlExtInForNMMStep.shape[0] === 1 && !lvlExtInForNMMStep.isDisposed && lvlExtInForNMMStep.dataSync().every(v => v ===0) ) lvlExtInForNMMStep.dispose();
        }

        Object.values(currentStepIntermediateOutputs).forEach(t => { if (t && !t.isDisposed) t.dispose(); });

        return { newlyRetrievedValues: newlyRetrievedValuesForAllLevelsDict, nextBotStates: nextBotLevelStatesList, anomalies: stepAnomalies, weightChanges: stepWeightChanges, buNorms: stepBuNorms, tdNorms: stepTdNorms, extNorms: stepExternalNorms };
    }

    dispose() {
        if (this.isDisposed) return;
        this.levels.forEach(l => {if (l && typeof l.dispose === 'function') l.dispose();});
        this.levels = []; this.isDisposed = true; hnmLog("HNS Disposed.");
    }
}

window.MemoryMLP_TFJS = MemoryMLP_TFJS;
window.NMM_TD_V5_TFJS = NMM_TD_V5_TFJS;
window.HierarchicalSystemV5_TFJS = HierarchicalSystemV5_TFJS;
window.createNeuralMemState = createNeuralMemState;
window.memStateDetach = memStateDetach;
window.disposeMemStateWeights = disposeMemStateWeights;
window.disposeHnsResultsTensors = disposeHnsResultsTensors;
window.hnmLog = hnmLog;

console.log("[HNM Core] Version 1.0.0 Loaded. Classes attached to window object.");
    </script>

    <script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.164.1/build/three.module.js",
            "three/addons/": "https://unpkg.com/three@0.164.1/examples/jsm/",
            "rapier3d-compat": "https://cdn.skypack.dev/@dimforge/rapier3d-compat",
            "lil-gui": "https://unpkg.com/lil-gui@0.19.1/dist/lil-gui.esm.js",
            "stats.js": "https://unpkg.com/three@0.164.1/examples/jsm/libs/stats.module.js"
        }
    }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import RAPIER_MODULE from 'rapier3d-compat';
        import GUI from 'lil-gui';
        import Stats from 'stats.js';

        if (typeof window.HierarchicalSystemV5_TFJS === 'undefined') {
            const err = "FATAL: hnm_core_v1.0.0.js not loaded. Check script tag.";
            document.getElementById('info').textContent = err; console.error(err); throw new Error(err);
        }

        let RAPIER, world, scene, camera, renderer, stats, gui, eventQueue, physicsLines = null;
        let player = { 
            mesh: null, rigidBody: null, collider: null, 
            armorSegmentLocalOffsets: [], isOnGround: false, 
            health: 100, maxHealth: 100,
            autoBattleTargetVelocity: new THREE.Vector3(),
            autoBattleFaceEnemy: false,
            autoBattleTargetEnemyPos: new THREE.Vector3()
        };
        let vine = { segments: [], joints: [] };
        let blades = [];

        let bciTargetWorldIndicatorMesh;
        let crosshairEl;

        let enemies = [];
        const PLAYER_MAX_HEALTH = 100;
        const ENEMY_MAX_HEALTH_BASE = 50;
        const ENEMY_DAMAGE_BASE = 10;
        const BLADE_HIT_DAMAGE = 20;
        let gameOver = false;

        const HNM_SENSORY_INPUT_DIM = 36; 
        const HNM_BCI_COMMAND_DIM = 4;   
        const VINE_RULE_ACTION_DIM_PER_SEGMENT = 3; 
        const BLADE_RULE_ACTION_DIM = 6;  

        let hnmVine, hnmBladesSystems = [];

        const userInput = {
            mouseX: 0, mouseY: 0, click: false,
            moveForward: 0, moveBackward: 0, moveLeft: 0, moveRight: 0, jump: false,
            bciCommandTarget: new THREE.Vector3(), 
            bciCommandTargetScreen: new THREE.Vector2(), 
            bciCommandTargetLastScreen: new THREE.Vector2(),
            bciCoherence: 0.0,
            bciAction: false, 
            cameraYaw: Math.PI, cameraPitch: 0.25,
            isPointerLocked: false,
            isBCIModeActive: false, 
            isBCITouchAiming: false, 
            bciTouchStart: {x:0, y:0},
            bciTouchCurrent: {x:0, y:0},
            isDirectControllingVine: false,
            directControlActionActive: false 
        };

        const params = {
            gravity: -15.0, playerSpeed: 8.0, playerJumpForce: 9.0,
            vineSegmentLength: 0.45, vineSegmentRadius: 0.07, numVineSegments: 12,
            vineForceScale: 55.0, vineDamping: 4.5, vineArmorSpringK: 60.0, vineArmorDampingK: 4.0,
            bladeForceScale: 45.0, bladeTorqueScale: 1.2, numBlades: 6, bladeOrbitRadiusBase: 2.5, bladeOrbitSpeed: 0.4,
            bladeReEngageSpeedThreshold: 0.75, bladeReEngageBackupDist: 1.5,
            showRapierDebug: false, enableHNM: true,
            resetSimulation: () => initDemo(true), 
            vineHnmLR: 0.00025, bladeHnmLR: 0.0003,
            bciTargetDistance: 15.0, mouseSensitivity: 0.0022,
            bciCoherenceBuildRate: 0.025, bciCoherenceDecayRate: 0.015, bciAimStabilityThreshold: 0.04,
            bciCoherenceBladeDeployThreshold: 0.35, bciCoherenceMinActionThreshold: 0.25, 
            deployOneBlade: () => deployBlades(1),
            recallAllBlades: () => recallAllBladesFunction(),
            toggleDirectVineControl: () => { userInput.isDirectControllingVine = !userInput.isDirectControllingVine; updateInfoDisplay();},
            numEnemies: 1, 
            autoBattleMode: false, 
        };
        
        class BCIEmulationProcessor {
            constructor(outputDim) { this.outputDim = outputDim; }
            process(currentInputState, currentBciTargetWorld) { 
                return tf.tidy(() => {
                    const commandStrength = currentInputState.bciCoherence;
                    const vec = [
                        currentBciTargetWorld.x * commandStrength,
                        currentBciTargetWorld.y * commandStrength,
                        currentBciTargetWorld.z * commandStrength,
                        (currentInputState.bciAction && commandStrength >= params.bciCoherenceMinActionThreshold) ? 1.0 : 0.0 
                    ];
                    while (vec.length < this.outputDim) vec.push(0.0); 
                    return tf.tensor1d(vec.slice(0, this.outputDim)).expandDims(0).expandDims(0); 
                });
            }
        }

        let bciProcessor = new BCIEmulationProcessor(HNM_BCI_COMMAND_DIM);
        let bciTargetWorld = new THREE.Vector3(); 

        async function setupTfBackend() {
            try {
                await tf.setBackend('webgl');
                console.log("TF.js: Using WebGL backend.");
                 tf.env().set('WEBGL_FORCE_F16_TEXTURES', true);
                 tf.env().set('WEBGL_PACK', true); 
                 tf.env().set('WEBGL_CONV_IM2COL', false); 
                 tf.env().set('WEBGL_USE_SHAPES_UNIFORMS', true);
            } catch (e) {
                console.warn("TF.js: WebGL backend failed, trying WASM.", e);
                try {
                    await tf.setBackend('wasm');
                    console.log("TF.js: Using WASM backend.");
                } catch (eWasm) {
                    console.warn("TF.js: WASM backend failed, using CPU.", eWasm);
                    await tf.setBackend('cpu');
                    console.log("TF.js: Using CPU backend.");
                }
            }
            await tf.ready();
            console.log(`TF.js Ready. Active backend: ${tf.getBackend()}`);
        }


        async function main() {
            await setupTfBackend(); // Initialize TF.js backend first
            await RAPIER_MODULE.init(); RAPIER = RAPIER_MODULE;
            bciTargetWorldIndicatorMesh = document.getElementById('bci-target-world-indicator');
            crosshairEl = document.getElementById('crosshair');
            initGraphics();
            initGUI(); 
            initDemo(true); 
            setupInputListeners();
            animate();
            updateInfoDisplay();
        }

        function definePlayerArmorOffsets() {
            player.armorSegmentLocalOffsets = [];
            const playerCapsuleRadius = 0.4;
            const playerCapsuleHalfHeight = 0.4; 
            const armorRadius = playerCapsuleRadius + 0.15; 
            const spirals = 2.2;
            const verticalSpreadFactor = 0.9; 

            for (let i = 0; i < params.numVineSegments; i++) {
                const t = i / Math.max(1, params.numVineSegments -1); 
                const yOffset = (t - 0.5) * (playerCapsuleHalfHeight * 2 * verticalSpreadFactor);
                const angle = (i * Math.PI * 2 * spirals) / params.numVineSegments + (Math.PI / params.numVineSegments * (i%2)); 
                player.armorSegmentLocalOffsets.push(new THREE.Vector3(Math.cos(angle) * armorRadius, yOffset, Math.sin(angle) * armorRadius));
            }
        }

        function initGraphics() {
            scene = new THREE.Scene();
            scene.fog = new THREE.Fog(0x1a1a1a, 20, 70);
            camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.1, 1000);
            renderer = new THREE.WebGLRenderer({ antialias: true, canvas: document.querySelector('canvas') || createCanvasElement() });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.shadowMap.enabled = true;
            if (!document.querySelector('canvas')) document.body.appendChild(renderer.domElement);
            scene.add(new THREE.AmbientLight(0x606070));
            const dirLight = new THREE.DirectionalLight(0xffffff, 1.5);
            dirLight.position.set(15, 25, 12);
            dirLight.castShadow = true;
            dirLight.shadow.mapSize.width = 1024; dirLight.shadow.mapSize.height = 1024;
            dirLight.shadow.camera.near = 0.5; dirLight.shadow.camera.far = 100;
            dirLight.shadow.camera.left = -30; dirLight.shadow.camera.right = 30;
            dirLight.shadow.camera.top = 30; dirLight.shadow.camera.bottom = -30;
            scene.add(dirLight);
            stats = new Stats(); document.getElementById('stats-container').appendChild(stats.dom);
            window.addEventListener('resize', onWindowResize);
        }
        function createCanvasElement() { const canvas = document.createElement('canvas'); document.body.insertBefore(canvas, document.getElementById('gui-container')); return canvas; }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight; camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function initGUI() {
            gui = new GUI({ container: document.getElementById('gui-container'), title: "HNM Vine/Blades Controls" });
            gui.add(params, 'gravity', -30, 0, 0.1).name('Gravity Y').onChange(v => { if(world) world.gravity.y = v;});
            gui.add(params, 'playerSpeed', 1, 20, 0.1); gui.add(params, 'playerJumpForce', 1, 20, 0.1);
            gui.add(params, 'mouseSensitivity', 0.0005, 0.005, 0.0001).name('Mouse Sensitivity');

            const vineFolder = gui.addFolder('Vine Config');
            vineFolder.add(params, 'numVineSegments', 1, 20, 1).name('Segments').onChange(() => initDemo(true)); 
            vineFolder.add(params, 'vineSegmentLength', 0.2, 1.0, 0.01).name('Seg Length').onChange(() => initDemo(true)); 
            vineFolder.add(params, 'vineSegmentRadius', 0.02, 0.2, 0.005).name('Seg Radius').onChange(() => initDemo(true)); 
            vineFolder.add(params, 'vineForceScale', 5, 200, 1).name('HNM Force Scale');
            vineFolder.add(params, 'vineDamping', 0.1, 15, 0.1).name('Rapier Damping');
            vineFolder.add(params, 'vineArmorSpringK', 5, 150, 1).name('Armor Spring K');
            vineFolder.add(params, 'vineArmorDampingK', 0.1, 15, 0.1).name('Armor Damping K');
            vineFolder.add(params, 'vineHnmLR', 0.000, 0.005, 0.00005).name('Vine HNM LR').onChange(updateHnmLearningRates);

            const bladesFolder = gui.addFolder('Blades Config');
            bladesFolder.add(params, 'numBlades', 1, 10, 1).name('Max Blades').onChange(() => initDemo(true)); 
            bladesFolder.add(params, 'bladeForceScale', 5, 200, 1).name('HNM Force Scale');
            bladesFolder.add(params, 'bladeTorqueScale', 0.01, 10, 0.01).name('HNM Torque Scale');
            bladesFolder.add(params, 'bladeOrbitRadiusBase', 1.0, 5.0, 0.1).name('Orbit Radius Base');
            bladesFolder.add(params, 'bladeOrbitSpeed', 0.1, 2.0, 0.05).name('Orbit Speed');
            bladesFolder.add(params, 'bladeReEngageSpeedThreshold', 0.1, 2.0, 0.05).name('Blade Re-Engage Min Speed');
            bladesFolder.add(params, 'bladeReEngageBackupDist', 0.5, 5.0, 0.1).name('Blade Re-Engage Backup Dist');
            bladesFolder.add(params, 'bciCoherenceBladeDeployThreshold', 0.0, 1.0, 0.01).name('Deploy Coherence Min');
            bladesFolder.add(params, 'deployOneBlade').name('Deploy One Blade');
            bladesFolder.add(params, 'recallAllBlades').name('Recall All Blades');
            bladesFolder.add(params, 'bladeHnmLR', 0.000, 0.005, 0.00005).name('Blades HNM LR').onChange(updateHnmLearningRates);

            const bciFolder = gui.addFolder('BCI Emulation');
            bciFolder.add(params, 'bciTargetDistance', 1, 50, 0.5).name('BCI Target Dist');
            bciFolder.add(params, 'bciCoherenceBuildRate', 0.001, 0.1, 0.001).name('Coherence Build');
            bciFolder.add(params, 'bciCoherenceDecayRate', 0.001, 0.1, 0.001).name('Coherence Decay');
            bciFolder.add(params, 'bciAimStabilityThreshold', 0.005, 0.2, 0.001).name('Aim Stability Thresh');
            bciFolder.add(params, 'bciCoherenceMinActionThreshold', 0.0, 1.0, 0.01).name('Min Coherence Action');
            
            const combatFolder = gui.addFolder('Combat Demo');
            combatFolder.add(params, 'numEnemies', 1, 5, 1).name('Number of Enemies').onChange(() => initDemo(true));
            combatFolder.add(params, 'autoBattleMode').name('Auto-Battle (Player AI)');


            gui.add(params, 'toggleDirectVineControl').name('Toggle Direct Vine Ctrl');
            gui.add(params, 'showRapierDebug').name('Show Rapier Debug').onChange( () => {
                if (!params.showRapierDebug && physicsLines) {
                    scene.remove(physicsLines);
                    if(physicsLines.geometry) physicsLines.geometry.dispose();
                    if(physicsLines.material) physicsLines.material.dispose();
                    physicsLines = null;
                }
            });
            gui.add(params, 'enableHNM').name('Enable HNMs');
            gui.add(params, 'resetSimulation').name('Full Reset Simulation');
        }

        function updateHnmLearningRates() {
            if (hnmVine && hnmVine.system && hnmVine.system.levels) {
                hnmVine.system.levels.forEach(level => {
                    if (level.optimizer) level.optimizer.learningRate = params.vineHnmLR;
                    level.nmmParams.learning_rate = params.vineHnmLR; 
                });
            }
            hnmBladesSystems.forEach(bladeHnm => {
                if (bladeHnm && bladeHnm.system && bladeHnm.system.levels) {
                    bladeHnm.system.levels.forEach(level => {
                        if (level.optimizer) level.optimizer.learningRate = params.bladeHnmLR;
                        level.nmmParams.learning_rate = params.bladeHnmLR;
                    });
                }
            });
        }

        async function initHNMSystems() {
            await tf.ready(); // Ensure TF is ready before HNM setup
            const hnmGlobalSimConfig = { HNM_VERBOSE: false };

            if (hnmVine) {
                if (hnmVine.system && !hnmVine.system.isDisposed) hnmVine.system.dispose();
                if (hnmVine.policyHead && typeof hnmVine.policyHead.dispose === 'function') hnmVine.policyHead.dispose();
            }

            const VINE_L0_EXTERNAL_DIM = HNM_BCI_COMMAND_DIM + (params.numVineSegments * VINE_RULE_ACTION_DIM_PER_SEGMENT);
            const vineHLC = [
                { name: "L0_Vine_Sensorimotor", dim: HNM_SENSORY_INPUT_DIM, raw_sensory_input_dim: HNM_SENSORY_INPUT_DIM, bu_source_level_names: [], td_source_level_names: ["L1_Vine_Context"], nmm_params: { learning_rate: params.vineHnmLR, external_signal_dim: VINE_L0_EXTERNAL_DIM, external_signal_role: "add_to_target" }, external_input_config: { source_signal_name: "VineL0CombinedSignal", dim: VINE_L0_EXTERNAL_DIM } },
                { name: "L1_Vine_Context", dim: HNM_SENSORY_INPUT_DIM * 2, bu_source_level_names: ["L0_Vine_Sensorimotor"], td_source_level_names: [], nmm_params: { learning_rate: params.vineHnmLR, mem_model_depth: 3, mem_model_expansion: 1.5 } }
            ];
            hnmVine = { system: new HierarchicalSystemV5_TFJS(vineHLC, hnmGlobalSimConfig), policyHeadInputLevelName: "L1_Vine_Context" };
            hnmVine.memoryState = hnmVine.system.getInitialStates(); hnmVine.lastStepOutputs = {};
            hnmVine.system.levelConfigsOriginal.forEach(lc => { hnmVine.lastStepOutputs[lc.name] = { retrievedVal: tf.keep(tf.zeros([1, 1, lc.dim])) }; });
            const vinePolicyInputDim = hnmVine.system.dims[hnmVine.policyHeadInputLevelName];
            hnmVine.policyHead = tf.sequential({ name: "VinePolicy" });
            hnmVine.policyHead.add(tf.layers.dense({ units: 64, inputShape: [vinePolicyInputDim], activation:'relu'}));
            hnmVine.policyHead.add(tf.layers.dense({ units: params.numVineSegments * VINE_RULE_ACTION_DIM_PER_SEGMENT, activation: 'tanh' }));

            hnmBladesSystems.forEach(existingHnm => {
                if(existingHnm) {
                    if (existingHnm.system && !existingHnm.system.isDisposed) existingHnm.system.dispose();
                    if (existingHnm.policyHead && typeof existingHnm.policyHead.dispose === 'function') existingHnm.policyHead.dispose();
                }
            });
            hnmBladesSystems = []; 

            const BLADE_L0_EXTERNAL_DIM = HNM_BCI_COMMAND_DIM + BLADE_RULE_ACTION_DIM;
            const bladeHLC_template = [
                { name: "L0_Blade_Sensorimotor", dim: HNM_SENSORY_INPUT_DIM, raw_sensory_input_dim: HNM_SENSORY_INPUT_DIM, bu_source_level_names: [], td_source_level_names: ["L1_Blade_Navigation"], nmm_params: { learning_rate: params.bladeHnmLR, external_signal_dim: BLADE_L0_EXTERNAL_DIM, external_signal_role: "add_to_target"}, external_input_config: {source_signal_name: "BladeL0CombinedSignal", dim: BLADE_L0_EXTERNAL_DIM}},
                { name: "L1_Blade_Navigation", dim: HNM_SENSORY_INPUT_DIM * 2, bu_source_level_names: ["L0_Blade_Sensorimotor"], td_source_level_names: [], nmm_params: { learning_rate: params.bladeHnmLR, mem_model_depth:3, mem_model_expansion:1.5}}
            ];
            for (let i = 0; i < params.numBlades; ++i) {
                const bladeHNM = { system: new HierarchicalSystemV5_TFJS(JSON.parse(JSON.stringify(bladeHLC_template)), hnmGlobalSimConfig), policyHeadInputLevelName: "L1_Blade_Navigation" };
                bladeHNM.memoryState = bladeHNM.system.getInitialStates(); bladeHNM.lastStepOutputs = {};
                bladeHNM.system.levelConfigsOriginal.forEach(lc => { bladeHNM.lastStepOutputs[lc.name] = { retrievedVal: tf.keep(tf.zeros([1, 1, lc.dim])) }; });
                const bladePolicyInputDim = bladeHNM.system.dims[bladeHNM.policyHeadInputLevelName];
                bladeHNM.policyHead = tf.sequential({name: `BladePolicy_${i}`});
                bladeHNM.policyHead.add(tf.layers.dense({ units: 64, inputShape: [bladePolicyInputDim], activation:'relu'}));
                bladeHNM.policyHead.add(tf.layers.dense({ units: BLADE_RULE_ACTION_DIM, activation: 'tanh' }));
                hnmBladesSystems.push(bladeHNM);
            }
            updateHnmLearningRates();
        }

        function cleanupPhysicsAndScene() {
            if (player?.mesh) scene.remove(player.mesh);
            player.mesh = null;

            if (vine?.segments) {
                vine.segments.forEach(s => { if(s.mesh) scene.remove(s.mesh); s.mesh = null; });
            }
            vine = { segments: [], joints: [] };

            blades.forEach(b => { if(b.mesh) scene.remove(b.mesh); b.mesh = null; });
            enemies.forEach(e => { if(e.mesh) scene.remove(e.mesh); e.mesh = null; });
            enemies = [];

            if (physicsLines) {
                scene.remove(physicsLines);
                if(physicsLines.geometry) physicsLines.geometry.dispose();
                if(physicsLines.material) physicsLines.material.dispose();
                physicsLines = null;
            }

            if (world) {
                world.free();
                world = null;
            }

            if (player) { player.rigidBody = null; player.collider = null; }
        }


        function initDemo(fullReset = false) { 
            console.log("Initializing Demo (Full Reset: " + fullReset + ")...");
            gameOver = false; 
            cleanupPhysicsAndScene(); 

            const initTasks = async () => {
                if (fullReset) { 
                    definePlayerArmorOffsets(); 
                    await initHNMSystems();
                }
                initPhysicsAndEntities();
                resetAndKeepHNMStates();
                updateInfoDisplay("Simulation " + (fullReset ? "Reset." : "Round Restarted."));
            };
            
            initTasks().catch(err => {
                console.error("Error during initDemo tasks:", err);
                updateInfoDisplay("ERROR initializing demo!");
            });
        }
        
        function resetAndKeepHNMStates() { 
             [hnmVine, ...hnmBladesSystems].forEach(hnmController => {
                if (hnmController && hnmController.system && !hnmController.system.isDisposed) {
                    if (hnmController.memoryState) {
                        hnmController.memoryState.forEach(s => window.disposeMemStateWeights(s));
                    }
                    hnmController.memoryState = hnmController.system.getInitialStates();
                    
                    if (hnmController.lastStepOutputs) {
                        Object.values(hnmController.lastStepOutputs).forEach(valObj => { if(valObj?.retrievedVal && !valObj.retrievedVal.isDisposed) valObj.retrievedVal.dispose();});
                    }
                    hnmController.lastStepOutputs = {};
                    hnmController.system.levelConfigsOriginal.forEach(lc => { hnmController.lastStepOutputs[lc.name] = { retrievedVal: tf.keep(tf.zeros([1, 1, lc.dim])) }; });
                } else if (hnmController) {
                    console.warn("Attempted to reset HNM state, but HNM system was invalid or disposed.");
                }
            });
        }

        function initPhysicsAndEntities() {
            world = new RAPIER.World({ x: 0, y: params.gravity, z: 0 });
            eventQueue = new RAPIER.EventQueue(true);
            const groundColliderDesc = RAPIER.ColliderDesc.cuboid(50, 0.1, 50).setTranslation(0,-0.1,0).setFriction(1.0);
            world.createCollider(groundColliderDesc);

            const playerMat = new THREE.MeshStandardMaterial({ color: 0x33dd33, emissive: 0x113311, roughness: 0.6, metalness: 0.2 });
            player.mesh = new THREE.Mesh(new THREE.CapsuleGeometry(0.4, 0.8, 4, 8), playerMat);
            player.mesh.castShadow = true;
            const playerBodyDesc = RAPIER.RigidBodyDesc.dynamic().setTranslation(0, 2.0, 0).setCanSleep(false).setLinearDamping(0.8).setAngularDamping(Math.PI);
            player.rigidBody = world.createRigidBody(playerBodyDesc);
            player.collider = world.createCollider(RAPIER.ColliderDesc.capsule(0.4, 0.4), player.rigidBody);
            player.rigidBody.lockRotations(true, true);
            player.collider.setActiveEvents(RAPIER.ActiveEvents.COLLISION_EVENTS); 
            player.rigidBody.userData = {entityType: "player", entityId: "player_0"};
            scene.add(player.mesh);
            player.isOnGround = false;
            player.health = PLAYER_MAX_HEALTH;
            player.maxHealth = PLAYER_MAX_HEALTH;
            player.autoBattleTargetVelocity = new THREE.Vector3();
            player.autoBattleFaceEnemy = false;
            player.autoBattleTargetEnemyPos = new THREE.Vector3();

            vine = { segments: [], joints: [] };
            let prevBody = player.rigidBody;
            let attachPointOnPrev = { x: 0, y: -0.4, z: 0 }; 

            for (let i = 0; i < params.numVineSegments; i++) {
                const playerWorldPos = player.rigidBody.translation();
                const playerWorldRot = player.rigidBody.rotation(); 
                const localOffset = player.armorSegmentLocalOffsets[i] || new THREE.Vector3(0, -(i+1)*params.vineSegmentLength, 0);
                const targetWorldPos = new THREE.Vector3(localOffset.x, localOffset.y, localOffset.z)
                                       .applyQuaternion(new THREE.Quaternion(playerWorldRot.x, playerWorldRot.y, playerWorldRot.z, playerWorldRot.w))
                                       .add(new THREE.Vector3(playerWorldPos.x, playerWorldPos.y, playerWorldPos.z));

                const segMat = new THREE.MeshStandardMaterial({ color: 0x774411, emissive:0x110500, roughness:0.7, metalness: 0.1});
                const seg = {
                    mesh: new THREE.Mesh(new THREE.CylinderGeometry(params.vineSegmentRadius, params.vineSegmentRadius, params.vineSegmentLength, 6), segMat),
                    id: `vineSeg_${i}`
                };
                seg.mesh.castShadow = true;
                const segBodyDesc = RAPIER.RigidBodyDesc.dynamic().setTranslation(targetWorldPos.x, targetWorldPos.y, targetWorldPos.z)
                    .setCanSleep(false).setLinearDamping(params.vineDamping).setAngularDamping(params.vineDamping);
                seg.rigidBody = world.createRigidBody(segBodyDesc);
                seg.collider = world.createCollider(RAPIER.ColliderDesc.capsule(params.vineSegmentLength / 2.0 - params.vineSegmentRadius, params.vineSegmentRadius).setDensity(0.1).setFriction(0.7), seg.rigidBody);
                scene.add(seg.mesh); vine.segments.push(seg);

                const attachPointOnSeg = { x: 0, y: params.vineSegmentLength / 2, z: 0 };
                const jointData = RAPIER.JointData.spherical(attachPointOnPrev, attachPointOnSeg);
                const joint = world.createImpulseJoint(jointData, prevBody, seg.rigidBody, true);
                joint.setContactsEnabled(false); vine.joints.push(joint);

                prevBody = seg.rigidBody;
                attachPointOnPrev = { x: 0, y: -params.vineSegmentLength / 2, z: 0 };
            }

            const bladeMat = new THREE.MeshStandardMaterial({ color: 0xb8b8d1, metalness: 0.95, roughness: 0.2, emissive: 0x101020});
            const newBladesArray = [];
            for (let i = 0; i < params.numBlades; ++i) {
                const newBlade = {
                    id: `blade_${i}`,
                    mesh: new THREE.Mesh(new THREE.BoxGeometry(0.7, 0.08, 0.15), bladeMat),
                    rigidBody: null, collider: null,
                    isStored: true,
                    hnm: hnmBladesSystems[i] 
                };
                newBlade.mesh.castShadow = true;
                newBlade.mesh.visible = false;
                scene.add(newBlade.mesh);
                newBladesArray.push(newBlade);
            }
            blades = newBladesArray;

            enemies = []; 
            const enemyMaterial = new THREE.MeshStandardMaterial({ color: 0xff6666, emissive: 0x441111, roughness:0.8 });
            for (let i = 0; i < params.numEnemies; i++) {
                const level = Math.floor(Math.random() * 3) + 1; 
                const size = 0.5 + level * 0.15; 
                const enemyMaxHealth = ENEMY_MAX_HEALTH_BASE + (level - 1) * 25; 
                const enemyDamage = ENEMY_DAMAGE_BASE + (level - 1) * 5; 

                const enemyMesh = new THREE.Mesh(new THREE.SphereGeometry(size, 12, 8), enemyMaterial);
                enemyMesh.castShadow = true;
                const spawnX = (Math.random() - 0.5) * 20;
                const spawnZ = (Math.random() - 0.5) * 20;
                const enemyBodyDesc = RAPIER.RigidBodyDesc.dynamic()
                    .setTranslation(spawnX, size, spawnZ)
                    .setCanSleep(false).setLinearDamping(0.5).setAngularDamping(0.5);
                const enemyBody = world.createRigidBody(enemyBodyDesc);
                const enemyCollider = world.createCollider(RAPIER.ColliderDesc.ball(size).setDensity(0.8), enemyBody);
                enemyCollider.setActiveEvents(RAPIER.ActiveEvents.COLLISION_EVENTS);
                const enemyId = `enemy_${i}_lvl${level}`;
                enemyBody.userData = { entityType: "enemy", entityId: enemyId, level: level };

                enemies.push({
                    id: enemyId,
                    mesh: enemyMesh,
                    rigidBody: enemyBody,
                    collider: enemyCollider,
                    health: enemyMaxHealth,
                    maxHealth: enemyMaxHealth,
                    damage: enemyDamage,
                    level: level,
                    attackCooldown: 0,
                    targetPlayer: true 
                });
                scene.add(enemyMesh);
            }
            updateHealthUIDisplay(); 
        }


        function updateEnemies(deltaTime) {
            if (gameOver) return;
            enemies.forEach(enemy => {
                if (enemy.health <= 0 || !enemy.rigidBody || !player || !player.rigidBody) return;

                const enemyPos = enemy.rigidBody.translation();
                const playerPosVec = player.rigidBody.translation(); // RAPIER vector
                const directionToPlayer = new THREE.Vector3(playerPosVec.x - enemyPos.x, 0, playerPosVec.z - enemyPos.z); 
                
                if (directionToPlayer.lengthSq() > 0.1) {
                    directionToPlayer.normalize();
                    const enemySpeed = 3.0 + enemy.level * 0.5; 
                    enemy.rigidBody.setLinvel({ x: directionToPlayer.x * enemySpeed, y: enemy.rigidBody.linvel().y, z: directionToPlayer.z * enemySpeed }, true);
                }

                if (enemy.attackCooldown > 0) {
                    enemy.attackCooldown -= deltaTime;
                }
            });
        }

        function handlePlayerDamage(amount, source = "unknown") {
            if (gameOver) return;
            player.health -= amount;
            updateInfoDisplay(`Player took ${amount} damage from ${source}! Health: ${player.health}`);
            updateHealthUIDisplay();
            if (player.health <= 0) {
                player.health = 0;
                gameOver = true;
                updateInfoDisplay("Player Defeated! Training session will restart.");
                setTimeout(() => initDemo(true), 3000); 
            }
        }

        function handleEnemyDamage(enemyId, amount, source="unknown") {
            if (gameOver) return;
            const enemy = enemies.find(e => e.id === enemyId);
            if (enemy && enemy.health > 0) {
                enemy.health -= amount;
                updateInfoDisplay(`Enemy ${enemyId} took ${amount} damage from ${source}! Health: ${enemy.health}`);
                updateHealthUIDisplay();
                if (enemy.health <= 0) {
                    enemy.health = 0;
                    updateInfoDisplay(`Enemy ${enemyId} defeated!`);
                    if (enemy.rigidBody) world.removeRigidBody(enemy.rigidBody);
                    if (enemy.mesh) scene.remove(enemy.mesh);
                    enemies = enemies.filter(e => e.id !== enemyId);
                    if (enemies.length === 0) {
                        gameOver = true;
                        updateInfoDisplay("All enemies defeated! Training session complete. Restarting...");
                        setTimeout(() => initDemo(true), 3000);
                    }
                }
            }
        }
        
        function updateHealthUIDisplay() {
            const playerHealthBarInner = document.querySelector('#player-health-bar .health-bar-inner');
            if (playerHealthBarInner) playerHealthBarInner.style.width = `${(player.health / player.maxHealth) * 100}%`;
            const playerHealthValueEl = document.getElementById('player-health-value');
            if(playerHealthValueEl) playerHealthValueEl.textContent = Math.max(0,Math.round(player.health));

            const enemiesContainer = document.getElementById('enemies-health-container');
            if (!enemiesContainer) return;
            enemiesContainer.innerHTML = ''; 

            enemies.forEach(enemy => {
                if(enemy.health <= 0) return; 
                const enemyHealthText = document.createElement('div');
                enemyHealthText.textContent = `Enemy ${enemy.id.split('_')[1]} (Lvl ${enemy.level}) Health: ${Math.max(0,Math.round(enemy.health))}`;
                const enemyBarDiv = document.createElement('div');
                enemyBarDiv.classList.add('health-bar');
                const enemyBarInnerDiv = document.createElement('div');
                enemyBarInnerDiv.classList.add('health-bar-inner', 'enemy');
                enemyBarInnerDiv.style.width = `${(enemy.health / enemy.maxHealth) * 100}%`;
                enemyBarDiv.appendChild(enemyBarInnerDiv);
                enemiesContainer.appendChild(enemyHealthText);
                enemiesContainer.appendChild(enemyBarDiv);
            });
        }


        function setupInputListeners() {
            const isTouchDevice = (('ontouchstart' in window) || (navigator.maxTouchPoints > 0) || (navigator.msMaxTouchPoints > 0));
            const addSafeEventListener = (element, event, handler, options = {}) => {
                if(element) element.addEventListener(event, handler, options);
                else console.warn(`Element not found for listener: ${event}`);
            };

            if (isTouchDevice) {
                addSafeEventListener(document.getElementById('btn-forward'), 'touchstart', (e)=>{e.preventDefault();userInput.moveForward=1;});
                addSafeEventListener(document.getElementById('btn-forward'), 'touchend', ()=>{userInput.moveForward=0;});
                addSafeEventListener(document.getElementById('btn-backward'), 'touchstart', (e)=>{e.preventDefault();userInput.moveBackward=1;});
                addSafeEventListener(document.getElementById('btn-backward'), 'touchend', ()=>{userInput.moveBackward=0;});
                addSafeEventListener(document.getElementById('btn-left'), 'touchstart', (e)=>{e.preventDefault();userInput.moveLeft=1;});
                addSafeEventListener(document.getElementById('btn-left'), 'touchend', ()=>{userInput.moveLeft=0;});
                addSafeEventListener(document.getElementById('btn-right'), 'touchstart', (e)=>{e.preventDefault();userInput.moveRight=1;});
                addSafeEventListener(document.getElementById('btn-right'), 'touchend', ()=>{userInput.moveRight=0;});
                addSafeEventListener(document.getElementById('btn-jump'), 'touchstart', (e)=>{e.preventDefault();userInput.jump=true;});
                addSafeEventListener(document.getElementById('btn-bci-action'), 'touchstart', (e)=>{e.preventDefault();userInput.bciAction=true; if (userInput.isDirectControllingVine) userInput.directControlActionActive = true; });
                addSafeEventListener(document.getElementById('btn-bci-action'), 'touchend', ()=>{userInput.bciAction=false; userInput.directControlActionActive = false;});

                const camSensitivity = 0.04;
                addSafeEventListener(document.getElementById('btn-cam-left'), 'touchstart', (e)=>{e.preventDefault();userInput.cameraYaw += camSensitivity;});
                addSafeEventListener(document.getElementById('btn-cam-right'), 'touchstart', (e)=>{e.preventDefault();userInput.cameraYaw -= camSensitivity;});

                const bciToggleBtn = document.getElementById('btn-bci-target-toggle');
                addSafeEventListener(bciToggleBtn, 'touchstart', (e)=>{ e.preventDefault(); userInput.isBCITouchAiming = true; if(bciToggleBtn) bciToggleBtn.style.backgroundColor = 'rgba(150,150,80,0.8)'; if(e.touches.length > 0) { userInput.bciTouchStart.x = userInput.bciTouchCurrent.x = e.touches[0].clientX; userInput.bciTouchStart.y = userInput.bciTouchCurrent.y = e.touches[0].clientY; userInput.bciCommandTargetScreen.set(userInput.bciTouchStart.x / window.innerWidth, userInput.bciTouchStart.y / window.innerHeight); userInput.bciCommandTargetLastScreen.copy(userInput.bciCommandTargetScreen); } });
                addSafeEventListener(window, 'touchmove', (e)=>{ if(userInput.isBCITouchAiming && e.touches.length > 0){ for(let i=0; i<e.touches.length; ++i){ if(e.touches[i].target === bciToggleBtn || e.touches[i].target === renderer.domElement){ userInput.bciTouchCurrent.x = e.touches[i].clientX; userInput.bciTouchCurrent.y = e.touches[i].clientY; userInput.bciCommandTargetScreen.set(userInput.bciTouchCurrent.x / window.innerWidth, userInput.bciTouchCurrent.y / window.innerHeight); break;}}}}, {passive:false});
                addSafeEventListener(bciToggleBtn, 'touchend', ()=>{ userInput.isBCITouchAiming = false; if(bciToggleBtn) bciToggleBtn.style.backgroundColor = 'rgba(100,100,100,0.7)';});

                addSafeEventListener(document.getElementById('btn-deploy-blade'), 'click', () => deployBlades(1));
                addSafeEventListener(document.getElementById('btn-recall-blades'), 'click', () => recallAllBladesFunction());
                addSafeEventListener(document.getElementById('btn-direct-vine'), 'click', () => {userInput.isDirectControllingVine = !userInput.isDirectControllingVine; updateInfoDisplay(); });
            } else { 
                addSafeEventListener(renderer.domElement, 'click', () => { if(!userInput.isPointerLocked) renderer.domElement.requestPointerLock(); });
                addSafeEventListener(document, 'pointerlockchange', () => { userInput.isPointerLocked = document.pointerLockElement === renderer.domElement; crosshairEl.style.display = userInput.isPointerLocked ? 'block' : 'none';}, false);
                addSafeEventListener(window, 'mousemove', (event) => {
                    if (userInput.isPointerLocked) {
                        userInput.cameraYaw -= event.movementX * params.mouseSensitivity;
                        userInput.cameraPitch += event.movementY * params.mouseSensitivity; 
                        userInput.cameraPitch = Math.max(-Math.PI/2 + 0.1, Math.min(Math.PI/2 - 0.1, userInput.cameraPitch));
                    }
                    if (userInput.isBCIModeActive) { 
                        userInput.bciCommandTargetScreen.set((event.clientX / window.innerWidth), (event.clientY / window.innerHeight));
                    }
                });
                addSafeEventListener(window, 'mousedown', (event) => { if (event.button === 0 && userInput.isBCIModeActive && event.ctrlKey) { event.preventDefault(); userInput.bciAction = true; if (userInput.isDirectControllingVine) userInput.directControlActionActive = true; }});
                addSafeEventListener(window, 'mouseup', (event) => { if (event.button === 0 && userInput.isBCIModeActive && event.ctrlKey) { event.preventDefault(); userInput.bciAction = false; userInput.directControlActionActive = false;} });

                addSafeEventListener(window, 'keydown', (event) => {
                    if (event.repeat || gameOver) return; 
                    if (event.key.toLowerCase() === 'shift') userInput.isBCIModeActive = true;
                    if (event.key.toLowerCase() === 'control' && userInput.isBCIModeActive) { userInput.bciAction = true; if (userInput.isDirectControllingVine) userInput.directControlActionActive = true;}
                    if (event.key.toLowerCase() === 'v' && !event.ctrlKey && !event.shiftKey) { userInput.isDirectControllingVine = !userInput.isDirectControllingVine; updateInfoDisplay(); }
                     if (event.key.toLowerCase() === '1' && !event.ctrlKey && !event.shiftKey) deployBlades(1);
                     if (event.key.toLowerCase() === 'r' && !event.ctrlKey && !event.shiftKey) recallAllBladesFunction();

                    switch(event.key.toLowerCase()) {
                        case 'w': userInput.moveForward = 1; break; case 's': userInput.moveBackward = 1; break;
                        case 'a': userInput.moveLeft = 1; break; case 'd': userInput.moveRight = 1; break;
                        case ' ': userInput.jump = true; event.preventDefault(); break;
                    }
                });
                addSafeEventListener(window, 'keyup', (event) => {
                    if (gameOver) return; 
                    if (event.key.toLowerCase() === 'shift') { userInput.isBCIModeActive = false; if (!event.ctrlKey) {userInput.bciAction = false; userInput.directControlActionActive = false;}}
                    if (event.key.toLowerCase() === 'control') { userInput.bciAction = false; userInput.directControlActionActive = false; if (!event.shiftKey) userInput.isBCIModeActive = false; }
                    switch(event.key.toLowerCase()) {
                        case 'w': userInput.moveForward = 0; break; case 's': userInput.moveBackward = 0; break;
                        case 'a': userInput.moveLeft = 0; break; case 'd': userInput.moveRight = 0; break;
                    }
                });
            }
        }

        function updatePlayerPhysicsIntent() {
            if (!player || !player.rigidBody || gameOver) return;

            const playerPhysicsPos = player.rigidBody.translation();
            const playerPhysicsLinvel = player.rigidBody.linvel();

            player.rigidBody.resetForces(true);

            if (params.autoBattleMode) {
                const ray = new RAPIER.Ray(playerPhysicsPos, { x: 0, y: -1, z: 0 });
                const hit = world.castRay(ray, 0.65, true, RAPIER.QueryFilterFlags.EXCLUDE_SENSORS, undefined, player.collider);
                player.isOnGround = hit ? true : false;

                let yVelForAuto = playerPhysicsLinvel.y;
                if (userInput.jump && player.isOnGround) {
                    yVelForAuto = params.playerJumpForce;
                    userInput.jump = false; 
                }
                const newLinvel = {
                    x: player.autoBattleTargetVelocity.x,
                    y: yVelForAuto,
                    z: player.autoBattleTargetVelocity.z
                };
                player.rigidBody.setLinvel(newLinvel, true);

            } else { // Manual mode
                const moveDirection = new THREE.Vector3();
                const playerFlatForward = new THREE.Vector3(Math.sin(userInput.cameraYaw), 0, Math.cos(userInput.cameraYaw)).normalize();
                const playerRight = new THREE.Vector3().crossVectors(new THREE.Vector3(0, 1, 0), playerFlatForward).normalize();

                if (userInput.moveForward) moveDirection.add(playerFlatForward);
                if (userInput.moveBackward) moveDirection.sub(playerFlatForward);
                if (userInput.moveLeft) moveDirection.add(playerRight);
                if (userInput.moveRight) moveDirection.sub(playerRight);

                moveDirection.normalize().multiplyScalar(params.playerSpeed);
                let yVel = playerPhysicsLinvel.y;

                const ray = new RAPIER.Ray(playerPhysicsPos, { x: 0, y: -1, z: 0 });
                const hit = world.castRay(ray, 0.65, true, RAPIER.QueryFilterFlags.EXCLUDE_SENSORS, undefined, player.collider);
                player.isOnGround = hit ? true : false;

                if (userInput.jump && player.isOnGround) {
                    yVel = params.playerJumpForce;
                    userInput.jump = false;
                }

                let newLinvel = { x: moveDirection.x, y: yVel, z: moveDirection.z };
                if (player.isOnGround && moveDirection.lengthSq() === 0) { 
                    newLinvel.x = playerPhysicsLinvel.x * 0.1;
                    newLinvel.z = playerPhysicsLinvel.z * 0.1;
                }
                player.rigidBody.setLinvel(newLinvel, true);
            }
        }


        function getEntitySensoryData(entity, playerEntity, currentBciTargetWorld, entityType = "vine_segment", allBlades = []) {
            const pos = entity.rigidBody.translation();
            const vel = entity.rigidBody.linvel();
            const rot = entity.rigidBody.rotation(); 
            const playerPos = playerEntity.rigidBody.translation();
            const playerRot = playerEntity.rigidBody.rotation(); 

            const worldPosToPlayer = new THREE.Vector3(pos.x - playerPos.x, pos.y - playerPos.y, pos.z - playerPos.z);
            const playerInverseQuatTHREE = new THREE.Quaternion(playerRot.x, playerRot.y, playerRot.z, playerRot.w).invert();
            const localPosRelToPlayer = worldPosToPlayer.clone().applyQuaternion(playerInverseQuatTHREE);

            const targetRelToEntity = new THREE.Vector3(currentBciTargetWorld.x - pos.x, currentBciTargetWorld.y - pos.y, currentBciTargetWorld.z - pos.z);
            const entityQuatTHREE = new THREE.Quaternion(rot.x, rot.y, rot.z, rot.w);
            const localTargetRelToEntity = targetRelToEntity.clone().applyQuaternion(entityQuatTHREE.clone().invert());

            const data = [
                localPosRelToPlayer.x/5, localPosRelToPlayer.y/5, localPosRelToPlayer.z/5,
                vel.x/5, vel.y/5, vel.z/5,
                rot.x, rot.y, rot.z, rot.w,
                localTargetRelToEntity.x/10, localTargetRelToEntity.y/10, localTargetRelToEntity.z/10,
                userInput.bciCoherence,
                (userInput.bciAction && userInput.bciCoherence >= params.bciCoherenceMinActionThreshold) ? 1.0 : 0.0,
                playerEntity.rigidBody.linvel().x/5, playerEntity.rigidBody.linvel().y/5, playerEntity.rigidBody.linvel().z/5,
                entityType === "vine_segment" ? 1 : 0, entityType === "blade" ? 1 : 0,
                worldPosToPlayer.length() / 10.0,
                entity.rigidBody.isSleeping() ? 1.0 : 0.0,
                playerEntity.isOnGround ? 1.0 : 0.0,
            ];

            if (entityType === "blade") {
                let closestBladeDist = 100.0; let secondClosestBladeDist = 100.0;
                let numVisibleOtherBlades = 0;
                allBlades.forEach(otherBlade => {
                    if (otherBlade.id !== entity.id && !otherBlade.isStored && otherBlade.rigidBody) {
                        const otherPos = otherBlade.rigidBody.translation();
                        const dist = Math.sqrt((pos.x-otherPos.x)**2 + (pos.y-otherPos.y)**2 + (pos.z-otherPos.z)**2);
                        numVisibleOtherBlades++;
                        if (dist < closestBladeDist) { secondClosestBladeDist = closestBladeDist; closestBladeDist = dist; }
                        else if (dist < secondClosestBladeDist) { secondClosestBladeDist = dist; }
                    }
                });
                data.push(Math.min(1.0, numVisibleOtherBlades / (params.numBlades -1 + 1e-6) ));
                data.push(closestBladeDist / 20.0); 
                data.push(secondClosestBladeDist / 20.0);
            } else { 
                data.push(0,0,0);
            }
            data.push(targetRelToEntity.x / 20.0, targetRelToEntity.y / 20.0, targetRelToEntity.z / 20.0);

            let nearestEnemyDist = 20.0;
            let nearestEnemyRelX = 0, nearestEnemyRelY = 0, nearestEnemyRelZ = 0;
            if (enemies.length > 0 && enemies[0].rigidBody && enemies[0].health > 0) { 
                const enemy0Pos = enemies[0].rigidBody.translation();
                const enemyRelPos = new THREE.Vector3(enemy0Pos.x - pos.x, enemy0Pos.y - pos.y, enemy0Pos.z - pos.z);
                nearestEnemyDist = enemyRelPos.length();
                if(nearestEnemyDist > 0.01) enemyRelPos.normalize();
                nearestEnemyRelX = enemyRelPos.x; nearestEnemyRelY = enemyRelPos.y; nearestEnemyRelZ = enemyRelPos.z;
            }
            data.push(nearestEnemyDist / 20.0);
            data.push(nearestEnemyRelX); data.push(nearestEnemyRelY); data.push(nearestEnemyRelZ);

            data.push(worldPosToPlayer.x / 10.0, worldPosToPlayer.y / 10.0, worldPosToPlayer.z / 10.0);

            while(data.length < HNM_SENSORY_INPUT_DIM) data.push(Math.random()*0.01 - 0.005);
            return tf.tensor1d(data.slice(0, HNM_SENSORY_INPUT_DIM)).expandDims(0).expandDims(0); 
        }


        function generateVineRuleActionVector(vineInstance, playerInstance, currentBciTargetWorld, currentBciCoherence, isBciActionActive) {
            const numSegments = params.numVineSegments;
            const ruleAction = new Array(numSegments * VINE_RULE_ACTION_DIM_PER_SEGMENT).fill(0.0);
            if (!playerInstance || !playerInstance.rigidBody) return tf.tensor1d(ruleAction).expandDims(0).expandDims(0);

            const playerPos = playerInstance.rigidBody.translation();
            const playerWorldQuatTHREE = new THREE.Quaternion(playerInstance.rigidBody.rotation().x, playerInstance.rigidBody.rotation().y, playerInstance.rigidBody.rotation().z, playerInstance.rigidBody.rotation().w);

            const isManipulatorIntent = currentBciCoherence > 0.4 && isBciActionActive; 
            const isDirectControlIntent = userInput.isDirectControllingVine && userInput.directControlActionActive;

            for (let i = 0; i < numSegments; i++) {
                const segment = vineInstance.segments[i];
                if (!segment || !segment.rigidBody) continue;
                const segPos = segment.rigidBody.translation();
                const segVel = segment.rigidBody.linvel();
                let targetWorldPosForRule;
                let forceMagnitudeFactor = 0.6; 

                if (isDirectControlIntent) {
                    targetWorldPosForRule = currentBciTargetWorld.clone();
                    forceMagnitudeFactor = 1.0; 
                } else if (isManipulatorIntent) {
                    targetWorldPosForRule = currentBciTargetWorld.clone();
                    forceMagnitudeFactor = 0.75;
                } else { 
                    const localOffset = playerInstance.armorSegmentLocalOffsets[i];
                    targetWorldPosForRule = new THREE.Vector3(localOffset.x, localOffset.y, localOffset.z)
                                           .applyQuaternion(playerWorldQuatTHREE)
                                           .add(new THREE.Vector3(playerPos.x, playerPos.y, playerPos.z));
                }

                const forceError = new THREE.Vector3().subVectors(targetWorldPosForRule, new THREE.Vector3(segPos.x, segPos.y, segPos.z));
                const springK = isDirectControlIntent ? params.vineArmorSpringK * 1.5 : params.vineArmorSpringK; 
                const dampingK = isDirectControlIntent ? params.vineArmorDampingK * 1.2 : params.vineArmorDampingK;
                const springForce = forceError.multiplyScalar(springK);
                const dampingForce = new THREE.Vector3(segVel.x, segVel.y, segVel.z).multiplyScalar(-dampingK);
                const totalForce = springForce.add(dampingForce);

                const maxComponent = Math.max(Math.abs(totalForce.x), Math.abs(totalForce.y), Math.abs(totalForce.z), 1.0);
                ruleAction[i * VINE_RULE_ACTION_DIM_PER_SEGMENT + 0] = THREE.MathUtils.clamp(totalForce.x / maxComponent, -1, 1) * forceMagnitudeFactor;
                ruleAction[i * VINE_RULE_ACTION_DIM_PER_SEGMENT + 1] = THREE.MathUtils.clamp(totalForce.y / maxComponent, -1, 1) * forceMagnitudeFactor;
                ruleAction[i * VINE_RULE_ACTION_DIM_PER_SEGMENT + 2] = THREE.MathUtils.clamp(totalForce.z / maxComponent, -1, 1) * forceMagnitudeFactor;
            }
            return tf.tensor1d(ruleAction).expandDims(0).expandDims(0); 
        }

        function generateBladeRuleActionVector(bladeInstance, playerInstance, currentBciTargetWorld, currentBciCoherence, isBciActionActive) {
            const ruleAction = new Array(BLADE_RULE_ACTION_DIM).fill(0.0);
            if (!bladeInstance || bladeInstance.isStored || !bladeInstance.rigidBody || !playerInstance || !playerInstance.rigidBody) {
                return tf.tensor1d(ruleAction).expandDims(0).expandDims(0);
            }

            const bladePosVec = bladeInstance.rigidBody.translation();
            const bladePos = new THREE.Vector3(bladePosVec.x, bladePosVec.y, bladePosVec.z);
            const playerPosVec = playerInstance.rigidBody.translation();
            const playerPos = new THREE.Vector3(playerPosVec.x, playerPosVec.y, playerPosVec.z);
            const bladeVelVec = bladeInstance.rigidBody.linvel();
            const bladeSpeed = Math.sqrt(bladeVelVec.x**2 + bladeVelVec.y**2 + bladeVelVec.z**2);


            const isAttackIntent = currentBciCoherence > params.bciCoherenceMinActionThreshold && isBciActionActive;
            let forceMagnitudeFactor = 0.6;
            let torqueMagnitudeFactor = 0.4;

            let effectiveTarget = currentBciTargetWorld.clone();
            
            if (params.autoBattleMode && isAttackIntent && enemies.length > 0) {
                const targetEnemy = enemies.find(e => { 
                    if (e.rigidBody && e.health > 0) {
                        const enemyP = e.rigidBody.translation();
                        return Math.abs(enemyP.x - currentBciTargetWorld.x) < 0.1 && Math.abs(enemyP.z - currentBciTargetWorld.z) < 0.1;
                    }
                    return false;
                }) || (enemies.find(e => e.rigidBody && e.health > 0));

                if (targetEnemy && targetEnemy.rigidBody) {
                    const enemyPos = targetEnemy.rigidBody.translation();
                    const enemyCollider = targetEnemy.collider;
                    let enemyTopY = enemyPos.y;
                    if (enemyCollider && enemyCollider.shape.type === RAPIER.ShapeType.Ball) {
                        enemyTopY = enemyPos.y + enemyCollider.shape.radius;
                    } else if (enemyCollider && enemyCollider.shape.type === RAPIER.ShapeType.Cuboid) {
                        enemyTopY = enemyPos.y + enemyCollider.shape.halfExtents.y;
                    }
                    const desiredFlightHeightOffset = 0.5; 
                    const minimumFlightHeight = playerPos.y > 1 ? playerPos.y * 0.5 : 1.0; 
                    effectiveTarget.set(enemyPos.x, Math.max(minimumFlightHeight, enemyTopY + desiredFlightHeightOffset), enemyPos.z);
                }
            }


            if (isAttackIntent) {
                const distToEffectiveTarget = bladePos.distanceTo(effectiveTarget);
                let dirToTarget = new THREE.Vector3().subVectors(effectiveTarget, bladePos); 

                if (distToEffectiveTarget < params.bladeReEngageBackupDist * 0.5 && bladeSpeed < params.bladeReEngageSpeedThreshold) {
                    const backupDir = new THREE.Vector3().subVectors(bladePos, effectiveTarget).normalize();
                    const backupTarget = bladePos.clone().addScaledVector(backupDir, params.bladeReEngageBackupDist);
                    dirToTarget.subVectors(backupTarget, bladePos);
                    forceMagnitudeFactor = 0.7; 
                    torqueMagnitudeFactor = 0.2; 
                } else {
                    forceMagnitudeFactor = 0.85;
                    torqueMagnitudeFactor = 0.6;
                }
                
                if (dirToTarget.lengthSq() > 0.01) dirToTarget.normalize(); else dirToTarget.set(0,0,0);
                ruleAction[0] = dirToTarget.x; ruleAction[1] = dirToTarget.y; ruleAction[2] = dirToTarget.z;

                const bladeRapierQuat = bladeInstance.rigidBody.rotation();
                const bladeThreeQuat = new THREE.Quaternion(bladeRapierQuat.x, bladeRapierQuat.y, bladeRapierQuat.z, bladeRapierQuat.w);
                const currentForward = new THREE.Vector3(0,0,1).applyQuaternion(bladeThreeQuat); 
                const targetRotAxis = new THREE.Vector3().crossVectors(currentForward, dirToTarget); 
                const angle = currentForward.angleTo(dirToTarget);

                if (angle > 0.05 && targetRotAxis.lengthSq() > 0.001) {
                    targetRotAxis.normalize();
                    const desiredAngVel = targetRotAxis.multiplyScalar(angle * 2.0); 
                    const currentAngVel = bladeInstance.rigidBody.angvel();
                    const torqueError = desiredAngVel.sub(new THREE.Vector3(currentAngVel.x, currentAngVel.y, currentAngVel.z));
                    ruleAction[3] = THREE.MathUtils.clamp(torqueError.x, -1, 1);
                    ruleAction[4] = THREE.MathUtils.clamp(torqueError.y, -1, 1);
                    ruleAction[5] = THREE.MathUtils.clamp(torqueError.z, -1, 1);
                }

            } else { // Orbit mode
                const bladeIndex = blades.findIndex(b => b.id === bladeInstance.id);
                const activeBladesCount = Math.max(1, blades.filter(b=>!b.isStored).length);
                const angleOffset = (bladeIndex * Math.PI * 2 / activeBladesCount) + performance.now() * 0.001 * params.bladeOrbitSpeed;
                const orbitRadius = params.bladeOrbitRadiusBase + (bladeIndex % 3) * 0.7; 
                const orbitHeightVariation = (bladeIndex % 2 === 0) ? 0.3 : -0.2;

                const orbitTargetX = playerPos.x + Math.cos(angleOffset) * orbitRadius;
                const orbitTargetZ = playerPos.z + Math.sin(angleOffset) * orbitRadius;
                const orbitTargetY = playerPos.y + 0.8 + orbitHeightVariation; 
                const dirToOrbit = new THREE.Vector3(orbitTargetX - bladePos.x, orbitTargetY - bladePos.y, orbitTargetZ - bladePos.z);

                if (dirToOrbit.lengthSq() > 0.1) dirToOrbit.normalize(); else dirToOrbit.set(0,0,0);
                ruleAction[0] = dirToOrbit.x; ruleAction[1] = dirToOrbit.y; ruleAction[2] = dirToOrbit.z;
                forceMagnitudeFactor = 0.5;

                const dirToPlayer = new THREE.Vector3().subVectors(playerPos, bladePos);
                if (dirToPlayer.lengthSq() > 0.01) dirToPlayer.normalize(); else dirToPlayer.set(0,0,0);

                const bladeRapierQuat = bladeInstance.rigidBody.rotation();
                const bladeThreeQuat = new THREE.Quaternion(bladeRapierQuat.x, bladeRapierQuat.y, bladeRapierQuat.z, bladeRapierQuat.w);
                const currentForward = new THREE.Vector3(0,0,1).applyQuaternion(bladeThreeQuat); 
                const targetRotAxis = new THREE.Vector3().crossVectors(currentForward, dirToPlayer);
                const angle = currentForward.angleTo(dirToPlayer);
                if (angle > 0.1 && targetRotAxis.lengthSq() > 0.001) {
                    targetRotAxis.normalize();
                    const desiredAngVel = targetRotAxis.multiplyScalar(angle * 1.0);
                    const currentAngVel = bladeInstance.rigidBody.angvel();
                    const torqueError = desiredAngVel.sub(new THREE.Vector3(currentAngVel.x, currentAngVel.y, currentAngVel.z));
                    ruleAction[3] = THREE.MathUtils.clamp(torqueError.x, -1, 1);
                    ruleAction[4] = THREE.MathUtils.clamp(torqueError.y, -1, 1);
                    ruleAction[5] = THREE.MathUtils.clamp(torqueError.z, -1, 1);
                    torqueMagnitudeFactor = 0.3;
                }
            }
            for(let i=0; i<3; ++i) ruleAction[i] *= forceMagnitudeFactor;
            for(let i=3; i<6; ++i) ruleAction[i] *= torqueMagnitudeFactor;

            return tf.tensor1d(ruleAction).expandDims(0).expandDims(0); 
        }


        function runHNMStepImpl(hnmController, sensoryInputTensor, externalInputsMap = null) {
             if (!hnmController || !hnmController.system || !sensoryInputTensor || !params.enableHNM) {
                if(sensoryInputTensor && !sensoryInputTensor.isDisposed) sensoryInputTensor.dispose();
                if(externalInputsMap){ Object.values(externalInputsMap).forEach(t => { if(t && !t.isDisposed) t.dispose(); }); }
                return null;
            }
            const hlc = hnmController.system.levelConfigsOriginal;
            const inputsForHNM = {};
            if (hlc[0] && (!hlc[0].bu_source_level_names || hlc[0].bu_source_level_names.length === 0) && hlc[0].raw_sensory_input_dim > 0) {
                inputsForHNM[hlc[0].name] = sensoryInputTensor; 
            } else { if(sensoryInputTensor && !sensoryInputTensor.isDisposed) sensoryInputTensor.dispose(); }

            const externalSignalSourcesForSystemStep = {};
            if (externalInputsMap) {
                hnmController.system.level_expected_external_details.forEach((expectedDetail) => { 
                    if (expectedDetail && expectedDetail.name && externalInputsMap[expectedDetail.name]) {
                        const providedTensor = externalInputsMap[expectedDetail.name];
                        if (providedTensor && !providedTensor.isDisposed && providedTensor.shape && providedTensor.shape.length === 3 && providedTensor.shape[2] === expectedDetail.dim) {
                            externalSignalSourcesForSystemStep[expectedDetail.name] = providedTensor;
                        } else {
                            console.warn(`HNM Step for ${hnmController.system.levelConfigsOriginal[0].name}: External signal ${expectedDetail.name} shape mismatch or invalid. Expected dim ${expectedDetail.dim}, got ${providedTensor?.shape}. Using zeros.`);
                            externalSignalSourcesForSystemStep[expectedDetail.name] = tf.keep(tf.zeros([1,1,expectedDetail.dim]));
                        }
                    } else if (expectedDetail && expectedDetail.name && expectedDetail.dim > 0) {
                         console.warn(`HNM Step for ${hnmController.system.levelConfigsOriginal[0].name}: Expected external signal ${expectedDetail.name} (dim ${expectedDetail.dim}) not found in externalInputsMap. Using zeros.`);
                         externalSignalSourcesForSystemStep[expectedDetail.name] = tf.keep(tf.zeros([1,1,expectedDetail.dim]));
                    }
                });
            }
            const lastOutputsForSystemStep = {};
            for (const key in hnmController.lastStepOutputs) {
                const valObj = hnmController.lastStepOutputs[key];
                if (valObj && valObj.retrievedVal && !valObj.retrievedVal.isDisposed) {
                    lastOutputsForSystemStep[key] = { retrievedVal: tf.keep(valObj.retrievedVal.clone()) };
                } else {
                    const levelDim = hnmController.system.dims[key] || HNM_SENSORY_INPUT_DIM;
                    lastOutputsForSystemStep[key] = { retrievedVal: tf.keep(tf.zeros([1, 1, levelDim])) };
                }
            }
            const keptMemoryStates = hnmController.memoryState.map(state => window.memStateDetach(state));
            const hnmStepResult = hnmController.system.step(keptMemoryStates, lastOutputsForSystemStep, inputsForHNM, externalSignalSourcesForSystemStep, true);

            Object.values(lastOutputsForSystemStep).forEach(obj => { if (obj && obj.retrievedVal && !obj.retrievedVal.isDisposed) obj.retrievedVal.dispose(); });
            keptMemoryStates.forEach(state => window.disposeMemStateWeights(state));

            hnmController.memoryState.forEach(state => window.disposeMemStateWeights(state));
            hnmController.memoryState = hnmStepResult.nextBotStates; 

            Object.values(hnmController.lastStepOutputs).forEach(valObj => { if (valObj?.retrievedVal && !valObj.retrievedVal.isDisposed) valObj.retrievedVal.dispose(); });
            hnmController.lastStepOutputs = hnmStepResult.newlyRetrievedValues;

            const policyInputTensorDirect = hnmStepResult.newlyRetrievedValues[hnmController.policyHeadInputLevelName]?.retrievedVal;
            let policyOutputActions = null;
            if (policyInputTensorDirect && !policyInputTensorDirect.isDisposed) {
                const policyOutputTensor = hnmController.policyHead.apply(policyInputTensorDirect.reshape([1, -1])); 
                policyOutputActions = policyOutputTensor.dataSync();
                policyOutputTensor.dispose();
            } else {
                console.warn(`Policy input tensor for ${hnmController.policyHeadInputLevelName} was invalid. Using zero actions.`);
                const policyOutputLayer = hnmController.policyHead.layers[hnmController.policyHead.layers.length - 1];
                policyOutputActions = new Array(policyOutputLayer.units).fill(0.0);
            }
            window.disposeHnsResultsTensors(hnmStepResult);
            return policyOutputActions;
        }

        let lastPolicyOutputs = { vine: null, blades: [] };

        function updateBCIAndHNMs() {
            if (!player || !player.rigidBody || gameOver) return;
            const playerPosVec = player.rigidBody.translation();
            const playerPos = new THREE.Vector3(playerPosVec.x, playerPosVec.y, playerPosVec.z);

            let currentBCITargetScreen;
            if (userInput.isBCITouchAiming) currentBCITargetScreen = userInput.bciCommandTargetScreen.clone();
            else currentBCITargetScreen = userInput.isBCIModeActive ? userInput.bciCommandTargetScreen.clone() : new THREE.Vector2(0,0);

            const aimMovementDelta = currentBCITargetScreen.distanceTo(userInput.bciCommandTargetLastScreen);
            userInput.bciCommandTargetLastScreen.copy(currentBCITargetScreen);

            if (userInput.isBCIModeActive || userInput.isBCITouchAiming) {
                if (userInput.bciAction) { 
                    if (aimMovementDelta < params.bciAimStabilityThreshold) userInput.bciCoherence = Math.min(1.0, userInput.bciCoherence + params.bciCoherenceBuildRate * 2.5);
                    else userInput.bciCoherence = Math.min(1.0, userInput.bciCoherence + params.bciCoherenceBuildRate * 0.8);
                } else { 
                     if (aimMovementDelta < params.bciAimStabilityThreshold * 0.5) userInput.bciCoherence = Math.min(1.0, userInput.bciCoherence + params.bciCoherenceBuildRate * 0.5); 
                     else userInput.bciCoherence = Math.max(0.0, userInput.bciCoherence - params.bciCoherenceDecayRate * 0.7);
                }

                const ndcTarget = new THREE.Vector3(currentBCITargetScreen.x * 2 - 1, -currentBCITargetScreen.y * 2 + 1, 0.5); 
                const worldTargetUnprojected = ndcTarget.unproject(camera);
                const rayDir = worldTargetUnprojected.sub(camera.position).normalize();
                bciTargetWorld.copy(camera.position).addScaledVector(rayDir, params.bciTargetDistance);

                bciTargetWorldIndicatorMesh.style.display = 'block';
                const screenPos = bciTargetWorld.clone().project(camera);
                bciTargetWorldIndicatorMesh.style.left = `${(screenPos.x * 0.5 + 0.5) * window.innerWidth}px`;
                bciTargetWorldIndicatorMesh.style.top = `${(-screenPos.y * 0.5 + 0.5) * window.innerHeight}px`;
                bciTargetWorldIndicatorMesh.style.opacity = userInput.bciCoherence * 0.7 + 0.15;
            } else {
                userInput.bciCoherence = Math.max(0.0, userInput.bciCoherence - params.bciCoherenceDecayRate);
                bciTargetWorldIndicatorMesh.style.display = 'none';
                const playerForward = new THREE.Vector3(0,0,-1).applyQuaternion(player.mesh.quaternion); 
                bciTargetWorld.copy(playerPos).addScaledVector(playerForward, 4.0).add(new THREE.Vector3(0,0.5,0)); 
            }
            
            if (params.autoBattleMode) {
                userInput.isBCIModeActive = true; 
                userInput.bciCoherence = 0.85; 
                
                player.autoBattleTargetVelocity.set(0,0,0); 
                player.autoBattleFaceEnemy = false;         
                userInput.jump = false;                    

                if (enemies.length > 0) {
                    let closestEnemy = null;
                    let minDistanceSq = Infinity;
                    enemies.forEach(enemy => {
                        if (enemy.rigidBody && enemy.health > 0) {
                            const enemyP = enemy.rigidBody.translation();
                            const distSq = playerPos.distanceToSquared(new THREE.Vector3(enemyP.x, enemyP.y, enemyP.z));
                            if (distSq < minDistanceSq) {
                                minDistanceSq = distSq;
                                closestEnemy = enemy;
                            }
                        }
                    });

                    if (closestEnemy && closestEnemy.rigidBody) {
                        const enemyPosVec = closestEnemy.rigidBody.translation();
                        const enemyPos = new THREE.Vector3(enemyPosVec.x, enemyPosVec.y, enemyPosVec.z);
                        bciTargetWorld.set(enemyPos.x, enemyPos.y + 0.5, enemyPos.z); 

                        player.autoBattleFaceEnemy = true;
                        player.autoBattleTargetEnemyPos.copy(enemyPos);

                        const distanceToEnemy = Math.sqrt(minDistanceSq);
                        const desiredDistance = params.bladeOrbitRadiusBase * 1.8;
                        const directionToEnemyWorld = new THREE.Vector3().subVectors(enemyPos, playerPos);
                        directionToEnemyWorld.y = 0;
                        if(directionToEnemyWorld.lengthSq() > 0.01) directionToEnemyWorld.normalize();


                        if (distanceToEnemy > desiredDistance + 0.5) {
                            player.autoBattleTargetVelocity.copy(directionToEnemyWorld).multiplyScalar(params.playerSpeed);
                        } else if (distanceToEnemy < desiredDistance - 0.5) {
                            player.autoBattleTargetVelocity.copy(directionToEnemyWorld).multiplyScalar(-params.playerSpeed);
                        } else {
                            player.autoBattleTargetVelocity.set(0,0,0); 
                        }
                        if (Math.random() < 0.015 && player.isOnGround) userInput.jump = true;

                        if (distanceToEnemy < params.bciTargetDistance * 0.95 && userInput.bciCoherence > 0.7) {
                            const activeBladesCount = blades.filter(b => !b.isStored).length;
                            if (activeBladesCount < params.numBlades && Math.random() < 0.08) { 
                                deployBlades(1);
                            }
                            userInput.bciAction = true; 
                        } else {
                            userInput.bciAction = false;
                        }
                    } else { 
                        userInput.bciAction = false;
                        player.autoBattleTargetVelocity.set(0,0,0);
                        const playerForward = new THREE.Vector3(0,0,-1).applyQuaternion(player.mesh.quaternion); 
                        bciTargetWorld.copy(playerPos).addScaledVector(playerForward, 4.0).add(new THREE.Vector3(0,0.5,0));
                    }
                } else { 
                    userInput.bciAction = false;
                    player.autoBattleTargetVelocity.set(0,0,0);
                    const playerForward = new THREE.Vector3(0,0,-1).applyQuaternion(player.mesh.quaternion); 
                    bciTargetWorld.copy(playerPos).addScaledVector(playerForward, 4.0).add(new THREE.Vector3(0,0.5,0));
                }
                userInput.moveForward = 0; userInput.moveBackward = 0; userInput.moveLeft = 0; userInput.moveRight = 0;
            }


            if (params.enableHNM) {
                tf.tidy(() => {
                    const bciCommandTensor = bciProcessor.process(userInput, bciTargetWorld); 

                    if (hnmVine && hnmVine.system && !hnmVine.system.isDisposed && vine.segments.length > 0) {
                        const representativeVineSegment = vine.segments[Math.floor(params.numVineSegments / 2)]; 
                        if (representativeVineSegment && representativeVineSegment.rigidBody) {
                            const vineSensoryData = getEntitySensoryData(representativeVineSegment, player, bciTargetWorld, "vine_segment");
                            const vineRuleActionTensor = generateVineRuleActionVector(vine, player, bciTargetWorld, userInput.bciCoherence, userInput.bciAction);
                            const vineCombinedExternalInput = tf.concat([bciCommandTensor.clone(), vineRuleActionTensor], 2);
                            const vineExtInputName = hnmVine.system.levelConfigsOriginal[0].external_input_config?.source_signal_name;
                            const vineExtInputs = vineExtInputName ? { [vineExtInputName]: vineCombinedExternalInput } : {};
                            lastPolicyOutputs.vine = runHNMStepImpl(hnmVine, vineSensoryData, vineExtInputs);
                        }
                    }

                    blades.forEach((blade, index) => {
                        if (!blade.isStored && blade.rigidBody && hnmBladesSystems[index] && hnmBladesSystems[index].system && !hnmBladesSystems[index].system.isDisposed) {
                            const bladeSensoryData = getEntitySensoryData(blade, player, bciTargetWorld, "blade", blades);
                            const bladeRuleActionTensor = generateBladeRuleActionVector(blade, player, bciTargetWorld, userInput.bciCoherence, userInput.bciAction);
                            const bladeCombinedExternalInput = tf.concat([bciCommandTensor.clone(), bladeRuleActionTensor], 2);
                            const bladeExtInputName = hnmBladesSystems[index].system.levelConfigsOriginal[0].external_input_config?.source_signal_name;
                            const bladeExtInputs = bladeExtInputName ? { [bladeExtInputName]: bladeCombinedExternalInput } : {};
                            
                            if(!lastPolicyOutputs.blades[index]) lastPolicyOutputs.blades[index] = new Array(BLADE_RULE_ACTION_DIM).fill(0);
                            lastPolicyOutputs.blades[index] = runHNMStepImpl(hnmBladesSystems[index], bladeSensoryData, bladeExtInputs);
                        }
                    });
                    bciCommandTensor.dispose(); 
                });
            } else { 
                if (vine.segments.length > 0) {
                    const vineRuleActionTensor = generateVineRuleActionVector(vine, player, bciTargetWorld, userInput.bciCoherence, userInput.bciAction);
                    lastPolicyOutputs.vine = vineRuleActionTensor.dataSync(); 
                    vineRuleActionTensor.dispose();
                }
                blades.forEach((blade, index) => {
                    if (!blade.isStored && blade.rigidBody) {
                        const bladeRuleActionTensor = generateBladeRuleActionVector(blade, player, bciTargetWorld, userInput.bciCoherence, userInput.bciAction);
                        lastPolicyOutputs.blades[index] = bladeRuleActionTensor.dataSync(); 
                        bladeRuleActionTensor.dispose();
                    } else {
                         lastPolicyOutputs.blades[index] = null; 
                    }
                });
            }
            updateInfoDisplay();
        }

        function applyDirectVineControl() {
            if (!userInput.isDirectControllingVine || !userInput.directControlActionActive || !vine || vine.segments.length === 0) return;
            const targetForce = params.vineForceScale * 2.0; 

            for (let i = 0; i < vine.segments.length; i++) {
                const seg = vine.segments[i];
                if (seg.rigidBody) {
                    const segPos = seg.rigidBody.translation();
                    const dirToTarget = new THREE.Vector3().subVectors(bciTargetWorld, new THREE.Vector3(segPos.x, segPos.y, segPos.z));
                    if (dirToTarget.lengthSq() > 0.01) dirToTarget.normalize(); else dirToTarget.set(0,0,0);

                    seg.rigidBody.resetForces(true);
                    seg.rigidBody.addForce(dirToTarget.multiplyScalar(targetForce), true);
                }
            }
        }

        function applyHNMOutputsAndDirectControlToEntities() {
            if (gameOver) return; 

            if (userInput.isDirectControllingVine && userInput.directControlActionActive) {
                applyDirectVineControl(); 
            } else if (lastPolicyOutputs.vine && vine.segments.length > 0) { 
                for (let i = 0; i < vine.segments.length; i++) {
                    const seg = vine.segments[i];
                    const actionStartIndex = i * VINE_RULE_ACTION_DIM_PER_SEGMENT;
                    if (lastPolicyOutputs.vine && lastPolicyOutputs.vine.length > actionStartIndex + 2 && seg.rigidBody) {
                        seg.rigidBody.resetForces(true); 
                        seg.rigidBody.addForce({
                            x: lastPolicyOutputs.vine[actionStartIndex] * params.vineForceScale,
                            y: lastPolicyOutputs.vine[actionStartIndex + 1] * params.vineForceScale,
                            z: lastPolicyOutputs.vine[actionStartIndex + 2] * params.vineForceScale
                        }, true);
                    }
                }
            }

            blades.forEach((blade, index) => {
                if(blade.isStored || !blade.rigidBody) return;
                if (lastPolicyOutputs.blades[index] && lastPolicyOutputs.blades[index].length === BLADE_RULE_ACTION_DIM) {
                    const actions = lastPolicyOutputs.blades[index];
                    blade.rigidBody.resetForces(true); blade.rigidBody.resetTorques(true);
                    blade.rigidBody.addForce({ x: actions[0] * params.bladeForceScale, y: actions[1] * params.bladeForceScale, z: actions[2] * params.bladeForceScale }, true);
                    blade.rigidBody.addTorque({ x: actions[3] * params.bladeTorqueScale, y: actions[4] * params.bladeTorqueScale, z: actions[5] * params.bladeTorqueScale }, true);
                }
            });
        }


        function deployBlades(countToDeploy) {
            if (!world || !player || !player.rigidBody || gameOver) return; 
            if (userInput.bciCoherence < params.bciCoherenceBladeDeployThreshold && !params.autoBattleMode) {
                updateInfoDisplay(`Blade deploy failed: Coherence ${userInput.bciCoherence.toFixed(2)} too low (Min: ${params.bciCoherenceBladeDeployThreshold})`);
                return;
            }
            let deployedCount = 0;
            const playerPos = player.rigidBody.translation();
            const playerRot = player.rigidBody.rotation(); 
            const playerThreeQuat = new THREE.Quaternion(playerRot.x, playerRot.y, playerRot.z, playerRot.w);

            for (let i = 0; i < blades.length && deployedCount < countToDeploy; i++) {
                const blade = blades[i];
                if (blade.isStored) {
                    const angleOffset = (Math.PI * 2 / params.numBlades) * i; 
                    const spawnOffsetLocal = new THREE.Vector3(
                        Math.cos(angleOffset) * (params.bladeOrbitRadiusBase * 0.5),
                        0.3, 
                        Math.sin(angleOffset) * (params.bladeOrbitRadiusBase * 0.5)
                    );
                    const spawnPosThree = spawnOffsetLocal.applyQuaternion(playerThreeQuat).add(new THREE.Vector3(playerPos.x,playerPos.y,playerPos.z));

                    const bladeBodyDesc = RAPIER.RigidBodyDesc.dynamic().setTranslation(spawnPosThree.x, spawnPosThree.y, spawnPosThree.z)
                        .setCanSleep(false).setGravityScale(0.02).setLinearDamping(0.6).setAngularDamping(0.8);
                    blade.rigidBody = world.createRigidBody(bladeBodyDesc);
                    blade.collider = world.createCollider(RAPIER.ColliderDesc.cuboid(0.35, 0.04, 0.075).setDensity(0.2).setFriction(0.5).setRestitution(0.3), blade.rigidBody);
                    blade.collider.setActiveEvents(RAPIER.ActiveEvents.COLLISION_EVENTS); 
                    blade.rigidBody.userData = {entityType: "blade", entityId: blade.id};

                    blade.mesh.position.copy(spawnPosThree);
                    blade.mesh.quaternion.copy(playerThreeQuat); 
                    blade.mesh.visible = true;
                    blade.isStored = false;

                    if (blade.hnm && blade.hnm.system && !blade.hnm.system.isDisposed) { 
                        blade.hnm.memoryState.forEach(s => window.disposeMemStateWeights(s));
                        blade.hnm.memoryState = blade.hnm.system.getInitialStates();
                        Object.values(blade.hnm.lastStepOutputs).forEach(valObj => { if(valObj?.retrievedVal && !valObj.retrievedVal.isDisposed) valObj.retrievedVal.dispose();});
                        blade.hnm.system.levelConfigsOriginal.forEach(lc => { blade.hnm.lastStepOutputs[lc.name] = { retrievedVal: tf.keep(tf.zeros([1, 1, lc.dim])) }; });
                    } else {
                         console.warn(`Blade ${blade.id} HNM system is invalid or disposed during deployment. State not reset.`);
                    }
                    deployedCount++;
                }
            }
            if(deployedCount > 0) updateInfoDisplay(`${deployedCount} Blade(s) Deployed.`);
             else updateInfoDisplay("No stored blades to deploy.");
        }

        function recallAllBladesFunction() {
            let recalledCount = 0;
            blades.forEach(blade => {
                if (!blade.isStored && blade.rigidBody) {
                    world.removeRigidBody(blade.rigidBody);
                    blade.rigidBody = null; blade.collider = null;
                    blade.mesh.visible = false; blade.isStored = true;
                    recalledCount++;
                }
            });
            if(recalledCount > 0) updateInfoDisplay(`${recalledCount} Blade(s) Recalled.`);
             else updateInfoDisplay("No active blades to recall.");
        }

        function updateInfoDisplay(message = "") {
            const activeBlades = blades.filter(b => !b.isStored).length;
            let statusText = `BCI Coherence: ${userInput.bciCoherence.toFixed(2)} | Blades: ${activeBlades}/${params.numBlades}<br/>`;
            statusText += `Vine Ctrl: ${userInput.isDirectControllingVine ? "Direct (BCI Trig)" : (params.enableHNM ? "HNM" : "Rules")} | Vine Action: ${userInput.bciCoherence > 0.4 && userInput.bciAction && !userInput.isDirectControllingVine ? "Manipulator" : "Armor"}<br/>`;
            statusText += `Player Health: ${player.health !== undefined ? Math.round(player.health) : 'N/A'}/${PLAYER_MAX_HEALTH} | Enemies Left: ${enemies.filter(e => e.health > 0).length}/${params.numEnemies}<br/>`;
            statusText += `Auto-Battle: ${params.autoBattleMode ? "ON" : "OFF"}<br/>`
            statusText += `Desktop: WASD/Space + Mouse. BCI Aim: Hold Shift. BCI Action: Hold Ctrl+Click (while Shift held). VineDirect: V. Blades: 1 (Deploy), R (Recall).<br/>`;
            statusText += `Mobile: On-screen controls. BCI Aim: Hold 'BCIAim', BCI Act: Tap 'BCIAct'.`;
            if (message) statusText += `<br/><i style="color:#ffffaa;">${message}</i>`;
            document.getElementById('info').innerHTML = statusText;
        }

        let lastFrameTime = performance.now();
        function animate() {
            requestAnimationFrame(animate);
            const time = performance.now();
            const deltaTime = Math.min(0.05, (time - lastFrameTime) / 1000.0); 
            lastFrameTime = time;

            if (!gameOver) { 
                updatePlayerPhysicsIntent();
                updateBCIAndHNMs(); 
                applyHNMOutputsAndDirectControlToEntities(); 
                updateEnemies(deltaTime); 
            }

            if(world) {
                world.step(eventQueue);
                eventQueue.drainCollisionEvents((handle1, handle2, started) => {
                    if (!started || gameOver) return; 

                    const col1 = world.getCollider(handle1);
                    const col2 = world.getCollider(handle2);

                    if (!col1 || !col2) return;

                    const parentBody1 = col1.parent();
                    const parentBody2 = col2.parent();
                    
                    const userData1 = parentBody1 ? parentBody1.userData : null;
                    const userData2 = parentBody2 ? parentBody2.userData : null;

                    if (userData1 && userData1.entityType === "blade" && userData2 && userData2.entityType === "enemy") {
                        const bladeBody = parentBody1;
                        const bladeVelocity = bladeBody.linvel();
                        const speed = Math.sqrt(bladeVelocity.x**2 + bladeVelocity.y**2 + bladeVelocity.z**2);
                        const damageMultiplier = Math.max(0.5, Math.min(2.5, speed / 5.0)); 
                        const finalDamage = BLADE_HIT_DAMAGE * damageMultiplier;
                        handleEnemyDamage(userData2.entityId, finalDamage, userData1.entityId);
                    } else if (userData2 && userData2.entityType === "blade" && userData1 && userData1.entityType === "enemy") {
                        const bladeBody = parentBody2;
                        const bladeVelocity = bladeBody.linvel();
                        const speed = Math.sqrt(bladeVelocity.x**2 + bladeVelocity.y**2 + bladeVelocity.z**2);
                        const damageMultiplier = Math.max(0.5, Math.min(2.5, speed / 5.0)); 
                        const finalDamage = BLADE_HIT_DAMAGE * damageMultiplier;
                        handleEnemyDamage(userData1.entityId, finalDamage, userData2.entityId);
                    }
                    else if (userData1 && userData1.entityType === "enemy" && userData2 && userData2.entityType === "player") {
                        const enemy = enemies.find(e => e.id === userData1.entityId);
                        if (enemy && enemy.attackCooldown <= 0) {
                            handlePlayerDamage(enemy.damage, enemy.id);
                            enemy.attackCooldown = 1.0 + Math.random() * 0.5; 
                        }
                    } else if (userData2 && userData2.entityType === "enemy" && userData1 && userData1.entityType === "player") {
                         const enemy = enemies.find(e => e.id === userData2.entityId);
                        if (enemy && enemy.attackCooldown <= 0) {
                            handlePlayerDamage(enemy.damage, enemy.id);
                            enemy.attackCooldown = 1.0 + Math.random() * 0.5; 
                        }
                    }
                });
            }

            // VISUAL UPDATES (POST PHYSICS STEP)
            if (player?.mesh && player.rigidBody) {
                const playerPhysicsPos = player.rigidBody.translation();
                player.mesh.position.set(playerPhysicsPos.x, playerPhysicsPos.y, playerPhysicsPos.z);

                let visualRotationQuaternion;
                if (params.autoBattleMode && player.autoBattleFaceEnemy && player.autoBattleTargetEnemyPos.lengthSq() > 0.001) {
                    const directionToTarget = new THREE.Vector3().subVectors(player.autoBattleTargetEnemyPos, player.mesh.position);
                    directionToTarget.y = 0;
                    if (directionToTarget.lengthSq() > 0.001) {
                        const targetYaw = Math.atan2(directionToTarget.x, directionToTarget.z);
                        visualRotationQuaternion = new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(0, 1, 0), targetYaw);
                        player.mesh.quaternion.slerp(visualRotationQuaternion, 0.15);
                    } else { // Fallback if target is too close or invalid
                        visualRotationQuaternion = new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(0, 1, 0), userInput.cameraYaw);
                        player.mesh.quaternion.copy(visualRotationQuaternion); 
                    }
                } else { // Manual mode or auto-battle without specific enemy facing
                    visualRotationQuaternion = new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(0, 1, 0), userInput.cameraYaw);
                    player.mesh.quaternion.copy(visualRotationQuaternion);
                }
                
                const camLookAtOffset = new THREE.Vector3(0, 0.8, 0);
                const camLookAtTarget = new THREE.Vector3(playerPhysicsPos.x, playerPhysicsPos.y, playerPhysicsPos.z).add(camLookAtOffset);
                const camDist = 5.5;
                const camOffsetX = camDist * Math.sin(userInput.cameraYaw) * Math.cos(userInput.cameraPitch);
                const camOffsetY = camDist * Math.sin(userInput.cameraPitch);
                const camOffsetZ = camDist * Math.cos(userInput.cameraYaw) * Math.cos(userInput.cameraPitch);
                camera.position.set(camLookAtTarget.x - camOffsetX, camLookAtTarget.y + camOffsetY, camLookAtTarget.z - camOffsetZ);
                camera.lookAt(camLookAtTarget);
            }

            vine?.segments.forEach(s => { if(s.mesh && s.rigidBody){const p=s.rigidBody.translation(); const q=s.rigidBody.rotation(); s.mesh.position.set(p.x,p.y,p.z); s.mesh.quaternion.set(q.x,q.y,q.z,q.w);}});
            blades.forEach(b => { if(!b.isStored && b.mesh && b.rigidBody){const p=b.rigidBody.translation(); const q=b.rigidBody.rotation(); b.mesh.position.set(p.x,p.y,p.z); b.mesh.quaternion.set(q.x,q.y,q.z,q.w);}});
            enemies.forEach(e => { if(e.health > 0 && e.mesh && e.rigidBody){const p=e.rigidBody.translation(); const q=e.rigidBody.rotation(); e.mesh.position.set(p.x,p.y,p.z); e.mesh.quaternion.set(q.x,q.y,q.z,q.w);}});

            const existingDebugLines = scene.getObjectByName("physicsDebugLines");
            if (existingDebugLines) { scene.remove(existingDebugLines); if(existingDebugLines.geometry) existingDebugLines.geometry.dispose(); if(existingDebugLines.material) existingDebugLines.material.dispose(); }
            if (physicsLines && physicsLines !== existingDebugLines) { if(physicsLines.parent) scene.remove(physicsLines); if(physicsLines.geometry) physicsLines.geometry.dispose(); if(physicsLines.material) physicsLines.material.dispose(); }
            physicsLines = null;

            if (params.showRapierDebug && world) {
                const buffers = world.debugRender();
                if (buffers && buffers.vertices && buffers.vertices.length > 0) {
                    const geometry = new THREE.BufferGeometry();
                    geometry.setAttribute('position', new THREE.BufferAttribute(buffers.vertices, 3));
                    geometry.setAttribute('color', new THREE.BufferAttribute(buffers.colors, 4));
                    const material = new THREE.LineBasicMaterial({ vertexColors: true, depthTest:false, transparent:true, opacity:0.7 });
                    physicsLines = new THREE.LineSegments(geometry, material);
                    physicsLines.name = "physicsDebugLines"; physicsLines.renderOrder = 999; scene.add(physicsLines);
                }
            }
            stats.update();
            renderer.render(scene, camera);
        }
        main().catch(error => { console.error("Error initializing demo:", error); document.getElementById('info').textContent = "Error: " + error.message + ". Check console."; });
    </script>
</body>
</html>

