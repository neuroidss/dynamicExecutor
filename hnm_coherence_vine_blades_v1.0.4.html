<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>HNM Coherence Vine Blades v1.0.5 (Blade Logic, Defeat Seq, HNM Core Embed)</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #1a1a1a; color: white; touch-action: none; font-family: Arial, sans-serif;}
        canvas { display: block; }
        .lil-gui.autoPlace {
            top: 10px !important;
            right: 10px !important;
            max-height: calc(100vh - 20px) !important;
            overflow-y: auto !important;
            z-index: 1000 !important;
        }
        .lil-gui {
             max-width: calc(100vw - 20px);
        }
        #stats-container { position: absolute; top: 10px; left: 10px; z-index: 100;}
        #info { position: absolute; bottom: 10px; left: 10px; font-size: 10px; z-index: 100; background-color: rgba(0,0,0,0.7); padding: 6px; border-radius: 4px; max-width: calc(100% - 20px); line-height: 1.35; }
        #mobile-controls { position: fixed; bottom: 10px; left: 50%; transform: translateX(-50%); display: none; flex-direction: column; gap: 6px; z-index: 101; pointer-events: none; opacity:0; background-color: rgba(20,20,20,0.8); padding:8px; border-radius: 10px; }
        #mobile-controls .control-row { display: flex; gap: 6px; justify-content: center; }
        #mobile-controls button { padding: 8px 10px; font-size: 12px; background-color: rgba(100,100,100,0.7); border: 1px solid #bbb; color: white; border-radius: 6px; min-width:40px; text-align:center; font-weight: bold;}
        #bci-target-world-indicator { position: absolute; width: 12px; height: 12px; border: 2px solid yellow; background-color: rgba(255,255,0,0.3); border-radius: 50%; display: none; z-index: 150; transform: translate(-50%, -50%); pointer-events: none; opacity: 0.5;}
        #crosshair { position: fixed; left: 50%; top: 50%; width: 2px; height: 2px; background-color: white; border-radius: 50%; transform: translate(-50%, -50%); pointer-events: none; display: none; z-index: 200; }
        #health-bars { position: absolute; top: 50px; left: 10px; z-index: 100; background-color: rgba(0,0,0,0.5); padding: 5px; border-radius: 3px; font-size: 10px; }
        .health-bar { width: 100px; height: 10px; background-color: #555; border: 1px solid #777; margin-bottom: 3px; }
        .health-bar-inner { height: 100%; background-color: lightgreen; width: 100%; }
        .health-bar-inner.enemy { background-color: red; }
        .health-bar-inner.flying-enemy { background-color: orange; }
        @media (pointer: coarse) {
            #mobile-controls { display: flex; pointer-events: auto; opacity:1;}
            canvas { cursor: default; }
            #info {font-size: 8px;}
        }
    </style>
</head>
<body>
    <div id="stats-container"></div>
    <div id="info">
        HNM Player Vine/Blades - Combat Demo v1.0.5 (Blade Logic, Defeat Seq, HNM Core Embed)<br/>
        Loading...
    </div>
    <div id="mobile-controls">
        <div class="control-row">
            <button id="btn-cam-left" style="font-size:10px;">CamL</button>
            <button id="btn-forward">▲</button>
            <button id="btn-cam-right" style="font-size:10px;">CamR</button>
            <button id="btn-bci-target-toggle" style="font-size:10px;">BCIAim</button>
        </div>
        <div class="control-row">
            <button id="btn-left">◀</button>
            <button id="btn-backward">▼</button>
            <button id="btn-right">▶</button>
            <button id="btn-bci-action" style="font-size:10px;">BCIAct</button>
        </div>
         <div class="control-row">
            <button id="btn-jump">Jump</button>
            <button id="btn-deploy-blade" style="font-size:9px;">Dep.Bl</button>
            <button id="btn-direct-vine" style="font-size:9px;">Dir.Vin</button>
            <button id="btn-recall-blades" style="font-size:9px;">Rec.Bl</button>
        </div>
    </div>
    <div id="bci-target-world-indicator"></div>
    <div id="crosshair"></div>
    <div id="health-bars">
        <div>Player Health: <span id="player-health-value">100</span></div>
        <div class="health-bar" id="player-health-bar"><div class="health-bar-inner"></div></div>
        <div id="enemies-health-container"></div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.17.0/dist/tf.min.js"></script>
    <script type="text/javascript">
// hnm_core_v1.js
// --- Logging Utility (Adapted for Resonant Artifacts context) ---
function hnmLog(message, level = "info") {
    console[level](`[HNM] ${message}`);
}

// --- TensorFlow.js dependent HNM Components ---

class MemoryMLP_TFJS {
    constructor(inputDim, depth, expansionOrTargetDim, namePrefix = '', activation = 'elu') {
        this.inputDim = inputDim;
        this.depth = depth;
        this.namePrefix = namePrefix;
        this.model = null;
        this.isDisposed = false;

        if (depth < 1) { this.isIdentity = true; return; }
        this.isIdentity = false;

        const layers = [];
        let currentLayerInputShape = [this.inputDim];

        for (let i = 0; i < depth; i++) {
            const isLast = i === (depth - 1);
            let currentLayerOutputUnits;

            if (depth === 1) { currentLayerOutputUnits = expansionOrTargetDim; }
            else { currentLayerOutputUnits = isLast ? this.inputDim : Math.floor(this.inputDim * expansionOrTargetDim); }

            const denseLayerConfig = {
                units: currentLayerOutputUnits, kernelInitializer: 'glorotUniform',
                biasInitializer: 'zeros', name: `${namePrefix}_mlp_dense_${i}`
            };
            if (i === 0) { denseLayerConfig.inputShape = currentLayerInputShape; }
            layers.push(tf.layers.dense(denseLayerConfig));
            currentLayerInputShape = [currentLayerOutputUnits];

            if (!isLast) { layers.push(tf.layers.activation({activation: activation, name: `${namePrefix}_mlp_act_${i}`})); }
        }
        this.model = tf.sequential({ name: `${namePrefix}_mlp_sequential`, layers });
    }

    call(inputs) {
        if (this.isDisposed) throw new Error(`${this.namePrefix} MLP model is disposed.`);
        if (this.isIdentity) return tf.keep(inputs.clone());
        if (!this.model) throw new Error (`MemoryMLP_TFJS (${this.namePrefix}): Model not initialized properly.`);
        return this.model.apply(inputs);
    }

    getWeights() {
        if (this.isDisposed || this.isIdentity || !this.model) return [];
        return this.model.getWeights().map(w => tf.keep(w.clone()));
    }

    setWeights(weights) {
        if (this.isDisposed || this.isIdentity || !this.model || !weights || weights.length === 0) return;
        this.model.setWeights(weights);
    }

    getTrainableVariables() {
        if (this.isDisposed || this.isIdentity || !this.model) return [];
        return this.model.trainableWeights.map(tw => tw.val);
    }

    dispose() {
        if (this.isDisposed) return;
        if (this.model && typeof this.model.dispose === 'function') { this.model.dispose(); }
        this.model = null; this.isDisposed = true;
    }
}

function createNeuralMemState(seq_index = 0, layerWeights = {}, optim_state = {}) {
    return { seq_index, layerWeights, optim_state };
}

function memStateDetach(state) {
    if (!state) return null;
    const detachedLayerWeights = {};
    for (const key in state.layerWeights) {
        if (Array.isArray(state.layerWeights[key])) {
            detachedLayerWeights[key] = state.layerWeights[key].map(t => {
                if (t && !t.isDisposed) return tf.keep(t.clone());
                hnmLog(`Warning: memStateDetach found disposed or null tensor for weight key ${key}. Returning null for this tensor.`, "warn");
                return null;
            }).filter(t => t !== null);
        } else {
            hnmLog(`Warning: memStateDetach encountered non-array weights for key ${key}`, "warn");
            detachedLayerWeights[key] = [];
        }
    }
    const detachedOptimState = JSON.parse(JSON.stringify(state.optim_state || {}));
    return createNeuralMemState(state.seq_index, detachedLayerWeights, detachedOptimState);
}

function disposeMemStateWeights(state) {
    if (state && state.layerWeights) {
        for (const key in state.layerWeights) {
            if (Array.isArray(state.layerWeights[key])) {
                state.layerWeights[key].forEach(t => { if (t && !t.isDisposed) t.dispose(); });
            }
        }
        state.layerWeights = {};
    }
}

function disposeHnsResultsTensors(hnsResults) {
    if (!hnsResults) return;
    const tensorDictionaries = [
        hnsResults.anomalies,
        hnsResults.weightChanges,
        hnsResults.buNorms,
        hnsResults.tdNorms,
        hnsResults.extNorms
    ];
    tensorDictionaries.forEach(dict => {
        if (dict) {
            Object.values(dict).forEach(tensor => {
                if (tensor && !tensor.isDisposed && typeof tensor.dispose === 'function') {
                    tensor.dispose();
                }
            });
        }
    });
}


class NMM_TD_V5_TFJS {
    constructor(config) {
        this.levelName = config.name; this.dim = config.dim;
        this.buInputDims = { ...(config.bu_input_dims || {}) };
        this.tdInputDims = { ...(config.td_input_dims || {}) };

        this.nmmParams = {
            mem_model_depth: 2,
            mem_model_expansion: 2.0,
            learning_rate: 0.000, // Effectively no training for this integration by default
            weight_decay: 0.000,  // No decay
            beta1: 0.9,
            beta2: 0.999,
            max_grad_norm: 1.0,
            external_signal_dim: config.nmm_params?.external_signal_dim || 0,
            external_signal_role: config.nmm_params?.external_signal_role || 'none',
            verbose: config.nmm_params?.verbose || false,
            ...(config.nmm_params || {}) // Allow overrides
        };
        if (this.nmmParams.learning_rate === 0) {
             if(this.nmmParams.verbose) hnmLog(`NMM_TD_V5_TFJS (${this.levelName}): LR is 0, training ops will be skipped.`);
        }

        this.memoryModel = new MemoryMLP_TFJS(
            this.dim,
            this.nmmParams.mem_model_depth,
            (this.nmmParams.mem_model_depth === 1) ? this.dim : this.nmmParams.mem_model_expansion,
            `${this.levelName}_mem_mlp`
        );
        this.toValueTarget = new MemoryMLP_TFJS(this.dim, 1, this.dim, `${this.levelName}_val_proj`);

        this.buProjections = {};
        for (const name in this.buInputDims) { this.buProjections[name] = new MemoryMLP_TFJS(this.buInputDims[name], 1, this.dim, `${this.levelName}_bu_proj_${name}`); }
        this.tdProjections = {};
        for (const name in this.tdInputDims) { this.tdProjections[name] = new MemoryMLP_TFJS(this.tdInputDims[name], 1, this.dim, `${this.levelName}_td_proj_${name}`); }

        this.externalSignalProjection = null;
        if (this.nmmParams.external_signal_dim > 0 && this.nmmParams.external_signal_role !== 'none') {
            this.externalSignalProjection = new MemoryMLP_TFJS(this.nmmParams.external_signal_dim, 1, this.dim, `${this.levelName}_ext_proj`);
        }

        this.lossFn = (labels, predictions) => tf.losses.meanSquaredError(labels, predictions);
        if (this.nmmParams.learning_rate > 0) {
            this.optimizer = tf.train.adam(this.nmmParams.learning_rate, this.nmmParams.beta1, this.nmmParams.beta2, 1e-7);
        } else {
            this.optimizer = null; // No optimizer if not learning
        }
        if(this.nmmParams.verbose) hnmLog(`NMM_TD_V5_TFJS (${this.levelName}): Dim=${this.dim}, ExtDim=${this.nmmParams.external_signal_dim}, Role=${this.nmmParams.external_signal_role}, LR=${this.nmmParams.learning_rate.toExponential(2)}`);
        this.isDisposed = false;
    }

    _getLayerWeights() {
        if (this.isDisposed) throw new Error(`${this.levelName} NMM is disposed.`);
        const weights = { memoryModel: this.memoryModel.getWeights(), toValueTarget: this.toValueTarget.getWeights() };
        for (const name in this.buProjections) { weights[`buProj_${name}`] = this.buProjections[name].getWeights(); }
        for (const name in this.tdProjections) { weights[`tdProj_${name}`] = this.tdProjections[name].getWeights(); }
        if (this.externalSignalProjection) { weights.externalSignalProjection = this.externalSignalProjection.getWeights(); }
        return weights;
    }

    _applyLayerWeights(layerWeights) {
        if (this.isDisposed) throw new Error(`${this.levelName} NMM is disposed.`);
        if (!layerWeights) return;

        const tempClonedWeights = {};
        for (const key in layerWeights) {
            if (Array.isArray(layerWeights[key])) {
                tempClonedWeights[key] = layerWeights[key].map(t => t && !t.isDisposed ? t.clone() : null).filter(t => t);
            }
        }

        this.memoryModel.setWeights(tempClonedWeights.memoryModel || []);
        this.toValueTarget.setWeights(tempClonedWeights.toValueTarget || []);
        for (const name in this.buProjections) { this.buProjections[name].setWeights(tempClonedWeights[`buProj_${name}`] || []); }
        for (const name in this.tdProjections) { this.tdProjections[name].setWeights(tempClonedWeights[`tdProj_${name}`] || []); }
        if (this.externalSignalProjection && tempClonedWeights.externalSignalProjection) { this.externalSignalProjection.setWeights(tempClonedWeights.externalSignalProjection || []); }

        for (const key in tempClonedWeights) {
            if (Array.isArray(tempClonedWeights[key])) {
                tempClonedWeights[key].forEach(t => { if (t && !t.isDisposed) t.dispose(); });
            }
        }
    }

    getInitialState() {
        if (this.isDisposed) throw new Error(`${this.levelName} NMM is disposed.`);
        return createNeuralMemState(0, this._getLayerWeights(), { lr: this.nmmParams.learning_rate, wd: this.nmmParams.weight_decay });
    }

   _calculateWeightChange(oldWeightsMap, newWeightsMap) {
        return tf.tidy(`${this.levelName}_WeightChange`,() => {
            if (this.nmmParams.learning_rate === 0) return tf.keep(tf.tensor(0.0)); // No change if not learning

            let totalDiffSqSum = tf.tensor(0.0);
             for (const key in newWeightsMap) {
                 const oldWArray = oldWeightsMap[key]; const newWArray = newWeightsMap[key];
                 if (oldWArray && newWArray && oldWArray.length === newWArray.length) {
                     for (let i = 0; i < newWArray.length; i++) {
                         const oldW = oldWArray[i]; const newW = newWArray[i];
                         if (oldW && newW && !oldW.isDisposed && !newW.isDisposed && oldW.shape.toString() === newW.shape.toString()) {
                             const diff = newW.sub(oldW);
                             totalDiffSqSum = totalDiffSqSum.add(diff.square().sum());
                             diff.dispose();
                         } else { if(this.nmmParams.verbose) hnmLog(`Warning: Tensor mismatch or disposal during weight change calc for ${key}[${i}]`, "warn"); }
                     }
                 }
             }
            return tf.keep(totalDiffSqSum.sqrt());
        });
    }


    forwardStep(buInputs, tdSignals, currentState, externalSignal = null, detachNextState = true) {
        if (this.isDisposed) throw new Error(`${this.levelName} NMM is disposed.`);

        const oldWeightsForChangeCalc = (this.nmmParams.learning_rate > 0) ? this._getLayerWeights() : null;
        this._applyLayerWeights(currentState.layerWeights);

        const resultsTidy = tf.tidy(`${this.levelName}_NMM_ForwardStep`, () => {
            const preparedInputs = tf.tidy(`${this.levelName}_InputPrep`, () => {
                const projectedBuSignals = [];
                for (const name in buInputs) {
                    if (this.buProjections[name] && buInputs[name] && !buInputs[name].isDisposed && buInputs[name].shape) {
                        projectedBuSignals.push(this.buProjections[name].call(buInputs[name].reshape([-1, this.buInputDims[name]])));
                    } else {
                        if(this.nmmParams.verbose) hnmLog(`Warning: Skipping BU input for ${name} in ${this.levelName}. Using zeros.`, "warn");
                        projectedBuSignals.push(tf.zeros([1, this.dim]));
                    }
                }
                const combBu = projectedBuSignals.length > 0 ? tf.addN(projectedBuSignals) : tf.zeros([1, this.dim]);
                projectedBuSignals.forEach(t => {if (t && !t.isDisposed) t.dispose(); });
                const cBuNorm = tf.norm(combBu);

                const projectedTdSignals = [];
                for (const name in tdSignals) {
                    if (this.tdProjections[name] && tdSignals[name] && !tdSignals[name].isDisposed && tdSignals[name].shape) {
                        projectedTdSignals.push(this.tdProjections[name].call(tdSignals[name].reshape([-1, this.tdInputDims[name]])));
                    } else {
                       if(this.nmmParams.verbose) hnmLog(`Warning: Skipping TD input for ${name} in ${this.levelName}. Using zeros.`, "warn");
                       projectedTdSignals.push(tf.zeros([1, this.dim]));
                    }
                }
                const combTd = projectedTdSignals.length > 0 ? tf.addN(projectedTdSignals) : tf.zeros([1, this.dim]);
                projectedTdSignals.forEach(t => {if (t && !t.isDisposed) t.dispose(); });
                const cTdNorm = tf.norm(combTd);

                let projExtSig = null;
                let cExtNorm = tf.tensor(0.0);
                if (this.nmmParams.external_signal_role !== 'none' && this.externalSignalProjection) {
                    if (externalSignal && !externalSignal.isDisposed && externalSignal.shape && externalSignal.shape.length === 3 && externalSignal.shape[externalSignal.shape.length -1] === this.nmmParams.external_signal_dim) {
                       projExtSig = this.externalSignalProjection.call(externalSignal.reshape([-1, this.nmmParams.external_signal_dim]));
                    } else {
                        if(this.nmmParams.verbose && externalSignal) hnmLog(`Warning: External signal for ${this.levelName} invalid. Using zeros. Expected dim ${this.nmmParams.external_signal_dim}, got shape ${externalSignal?.shape}`, "warn");
                        else if (this.nmmParams.verbose && !externalSignal && this.nmmParams.external_signal_dim > 0) hnmLog(`Warning: External signal for ${this.levelName} missing. Using zeros. Expected dim ${this.nmmParams.external_signal_dim}`, "warn");
                        projExtSig = tf.zeros([1, this.dim]);
                    }
                    cExtNorm.dispose();
                    cExtNorm = tf.norm(projExtSig);
                }

                let keyBaseForPredictionTarget = combBu.clone();
                if (this.nmmParams.external_signal_role === 'add_to_bu' && projExtSig) {
                    keyBaseForPredictionTarget = keyBaseForPredictionTarget.add(projExtSig);
                }

                let mInput = combBu.add(combTd);
                if (this.nmmParams.external_signal_role === 'add_to_bu' && projExtSig) {
                    mInput = mInput.add(projExtSig);
                } else if (this.nmmParams.external_signal_role === 'add_to_td' && projExtSig) {
                    mInput = mInput.add(projExtSig);
                }

                let fValTarget = this.toValueTarget.call(keyBaseForPredictionTarget);
                if (this.nmmParams.external_signal_role === 'add_to_target' && projExtSig) {
                    fValTarget = fValTarget.add(projExtSig);
                }
                if (projExtSig && projExtSig !== externalSignal && !projExtSig.isDisposed && projExtSig.rank > 0) projExtSig.dispose();

                return { memInput: mInput, finalValTarget: fValTarget, currentBuNorm: cBuNorm, currentTdNorm: cTdNorm, currentExtNorm: cExtNorm };
            });

            const keptBuNorm = tf.keep(preparedInputs.currentBuNorm);
            const keptTdNorm = tf.keep(preparedInputs.currentTdNorm);
            const keptExtNorm = tf.keep(preparedInputs.currentExtNorm);

            const predictionBeforeTrain = this.memoryModel.call(preparedInputs.memInput);
            const keptPredictionForOutput = tf.keep(predictionBeforeTrain.clone().reshape([1, 1, this.dim]));

            let currentLossTensor = tf.tensor(0.0);

            if (this.optimizer && this.nmmParams.learning_rate > 0) {
                const trainableVarsForOptimizer = [];
                this.memoryModel.getTrainableVariables().forEach(v => trainableVarsForOptimizer.push(v));
                if (this.externalSignalProjection && this.nmmParams.external_signal_role !== 'none' && this.nmmParams.external_signal_dim > 0) {
                     this.externalSignalProjection.getTrainableVariables().forEach(v => trainableVarsForOptimizer.push(v));
                }

                if (trainableVarsForOptimizer.length > 0) {
                    const calculateLossFn = () => {
                        const currentPred = this.memoryModel.call(preparedInputs.memInput);
                        let mseLoss = this.lossFn(preparedInputs.finalValTarget, currentPred);
                        if (this.nmmParams.weight_decay > 0) {
                            let l2Loss = tf.tensor(0.0);
                            trainableVarsForOptimizer.forEach(v => { if (v.name.includes('kernel')) { l2Loss = l2Loss.add(v.square().sum()); } });
                            mseLoss = mseLoss.add(l2Loss.mul(this.nmmParams.weight_decay / 2));
                            l2Loss.dispose();
                        }
                        return mseLoss;
                    };

                    if (this.nmmParams.max_grad_norm && this.nmmParams.max_grad_norm > 0) {
                        const {value, grads} = this.optimizer.computeGradients(calculateLossFn, trainableVarsForOptimizer);
                        currentLossTensor.dispose(); currentLossTensor = value ? tf.keep(value) : tf.keep(tf.tensor(0.0));
                         if (grads) {
                            const gradArray = trainableVarsForOptimizer.map(v => grads[v.name]).filter(g => g && !g.isDisposed);
                            let finalGradsForApply = {};
                            if (gradArray.length > 0) {
                                const globalNorm = tf.tidy('globalNormCalc', () => { let totalNormSq = tf.scalar(0.0); for (const grad of gradArray) { totalNormSq = totalNormSq.add(tf.norm(grad).square()); } return totalNormSq.sqrt(); });
                                const globalNormVal = globalNorm.dataSync()[0]; globalNorm.dispose();
                                let clipRatioScalar = null; if (globalNormVal > this.nmmParams.max_grad_norm) { clipRatioScalar = tf.scalar(this.nmmParams.max_grad_norm / (globalNormVal + 1e-6)); }
                                trainableVarsForOptimizer.forEach(v => { if (grads[v.name] && !grads[v.name].isDisposed) { finalGradsForApply[v.name] = clipRatioScalar ? grads[v.name].mul(clipRatioScalar) : grads[v.name].clone(); } });
                                if (clipRatioScalar) clipRatioScalar.dispose();
                            }
                            this.optimizer.applyGradients(finalGradsForApply);
                            trainableVarsForOptimizer.forEach(v => { if (grads[v.name] && !grads[v.name].isDisposed) grads[v.name].dispose(); });
                            Object.values(finalGradsForApply).forEach(g => {if (g && !g.isDisposed) g.dispose(); });
                         } else { if(this.nmmParams.verbose) hnmLog(`Warning: Grads object from computeGradients is null/undefined for NMM ${this.levelName}.`, "warn");}
                    } else {
                        const lossTensorFromOptimizer = this.optimizer.minimize(calculateLossFn, true, trainableVarsForOptimizer);
                        currentLossTensor.dispose(); currentLossTensor = lossTensorFromOptimizer ? tf.keep(lossTensorFromOptimizer) : tf.keep(tf.tensor(0.0));
                    }
                } else { if(this.nmmParams.verbose) hnmLog(`Warning: No trainable variables for NMM ${this.levelName}. Training skipped.`, "warn"); }
            } else {
                currentLossTensor.dispose();
                currentLossTensor = tf.keep(this.lossFn(predictionBeforeTrain, preparedInputs.finalValTarget));
            }
            if (preparedInputs.memInput && !preparedInputs.memInput.isDisposed) preparedInputs.memInput.dispose();
            if (preparedInputs.finalValTarget && !preparedInputs.finalValTarget.isDisposed) preparedInputs.finalValTarget.dispose();

            return { prediction: keptPredictionForOutput, loss: currentLossTensor, buNorm: keptBuNorm, tdNorm: keptTdNorm, extNorm: keptExtNorm };
        });

        const retrievedValForOutput = resultsTidy.prediction;
        const lossVal = resultsTidy.loss;
        const buNormVal = resultsTidy.buNorm;
        const tdNormVal = resultsTidy.tdNorm;
        const extNormVal = resultsTidy.extNorm;

        let weightChangeVal;
        let newModelWeightsAfterTraining;
        if (this.nmmParams.learning_rate > 0 && oldWeightsForChangeCalc) {
            newModelWeightsAfterTraining = this._getLayerWeights();
            weightChangeVal = this._calculateWeightChange(oldWeightsForChangeCalc, newModelWeightsAfterTraining);
            Object.values(oldWeightsForChangeCalc).forEach(arr => arr.forEach(t => { if (t && !t.isDisposed) t.dispose(); }));
        } else {
            weightChangeVal = tf.keep(tf.tensor(0.0));
            newModelWeightsAfterTraining = currentState.layerWeights;
        }


        const nextStateInterim = createNeuralMemState(currentState.seq_index + 1, newModelWeightsAfterTraining, currentState.optim_state);
        const nextStateFinal = detachNextState ? memStateDetach(nextStateInterim) : nextStateInterim;
        if (detachNextState && this.nmmParams.learning_rate > 0 && newModelWeightsAfterTraining !== currentState.layerWeights) {
             disposeMemStateWeights(nextStateInterim);
        } else if (detachNextState && this.nmmParams.learning_rate === 0) {
            // No disposal needed here if not training, as memStateDetach clones.
        }


        return { retrievedVal: retrievedValForOutput, nextState: nextStateFinal, anomalyScore: lossVal, weightChange: weightChangeVal, buNorm: buNormVal, tdNorm: tdNormVal, extNorm: extNormVal };
    }

    dispose() {
        if (this.isDisposed) return;
        this.memoryModel.dispose(); this.toValueTarget.dispose();
        Object.values(this.buProjections).forEach(p => p.dispose()); Object.values(this.tdProjections).forEach(p => p.dispose());
        if(this.externalSignalProjection) this.externalSignalProjection.dispose();
        this.isDisposed = true; hnmLog(`NMM ${this.levelName} disposed.`);
    }
}


class HierarchicalSystemV5_TFJS {
    constructor(levelConfigsHLC, globalSimConfig) {
        this.levelConfigsOriginal = JSON.parse(JSON.stringify(levelConfigsHLC));
        this.globalConfig = globalSimConfig;
        this.numLevels = 0; this.levels = [];
        this.levelNameToIndex = {}; this.dims = {}; this.isDisposed = false;
        this.level_expected_external_details = [];

        this._initializeLevels();
    }

    _initializeLevels() {
        hnmLog(`HS_V5_TFJS: Initializing ${this.levelConfigsOriginal.length} levels.`);
        this.levelConfigsOriginal.forEach((cfg, i) => {
            if (!cfg.name || !cfg.dim) throw new Error(`Level ${i} config missing name or dim.`);
            this.levelNameToIndex[cfg.name] = i; this.dims[cfg.name] = cfg.dim;
        });

        this.levelConfigsOriginal.forEach((hlc_level_cfg, i) => {
            const nmmConstructorConfig = {
                name: hlc_level_cfg.name,
                dim: hlc_level_cfg.dim,
                bu_input_dims: {},
                td_input_dims: {},
                nmm_params: {
                    verbose: this.globalConfig.HNM_VERBOSE || false,
                    learning_rate: 0.000, // Defaulting to no learning for this integration
                    weight_decay: 0.000,
                    beta1: 0.9, beta2: 0.999, max_grad_norm: 1.0,
                    external_signal_dim: 0, external_signal_role: 'none',
                    mem_model_depth: 2, mem_model_expansion: 2.0,
                    ...(hlc_level_cfg.nmm_params || {})
                }
            };

            if (!hlc_level_cfg.bu_source_level_names || hlc_level_cfg.bu_source_level_names.length === 0) {
                if (!hlc_level_cfg.raw_sensory_input_dim || hlc_level_cfg.raw_sensory_input_dim <= 0) {
                    throw new Error(`Lvl '${hlc_level_cfg.name}' is a sensory level but lacks a valid 'raw_sensory_input_dim'.`);
                }
                nmmConstructorConfig.bu_input_dims[hlc_level_cfg.name] = hlc_level_cfg.raw_sensory_input_dim;
            } else {
                hlc_level_cfg.bu_source_level_names.forEach(srcName => {
                    if (!this.dims[srcName]) throw new Error(`Unknown BU source '${srcName}' for level '${hlc_level_cfg.name}'.`);
                    nmmConstructorConfig.bu_input_dims[srcName] = this.dims[srcName];
                });
            }
            if (hlc_level_cfg.td_source_level_names) {
                 hlc_level_cfg.td_source_level_names.forEach(srcName => {
                    if (!this.dims[srcName]) throw new Error(`Unknown TD source '${srcName}' for level '${hlc_level_cfg.name}'.`);
                    nmmConstructorConfig.td_input_dims[srcName] = this.dims[srcName];
                });
            }

            let expectedNmmExtSourceName = null;
            let nmmExtSignalDimForNMM = 0;
            let nmmExtSignalRoleForNMM = nmmConstructorConfig.nmm_params.external_signal_role;

            const specificExtConfig = hlc_level_cfg.external_input_config;
            if (specificExtConfig && typeof specificExtConfig === 'object' && !Array.isArray(specificExtConfig) &&
                specificExtConfig.source_signal_name && specificExtConfig.dim > 0) {

                expectedNmmExtSourceName = specificExtConfig.source_signal_name;
                nmmExtSignalDimForNMM = specificExtConfig.dim;

                if (specificExtConfig.role) { // Role from external_input_config overrides nmm_params for this signal
                    nmmExtSignalRoleForNMM = specificExtConfig.role;
                } else if (nmmExtSignalDimForNMM > 0 && nmmExtSignalRoleForNMM === 'none') {
                    nmmExtSignalRoleForNMM = 'add_to_bu'; // Default if dim provided but no role
                }
            } else if (specificExtConfig && nmmConstructorConfig.nmm_params.verbose) {
                hnmLog(`Warning for ${hlc_level_cfg.name}: external_input_config is present but invalid or incomplete. ${JSON.stringify(specificExtConfig)}`, "warn");
            }

            nmmConstructorConfig.nmm_params.external_signal_dim = nmmExtSignalDimForNMM;
            nmmConstructorConfig.nmm_params.external_signal_role = nmmExtSignalRoleForNMM;
            this.level_expected_external_details[i] = { name: expectedNmmExtSourceName, dim: nmmExtSignalDimForNMM };

            this.levels.push(new NMM_TD_V5_TFJS(nmmConstructorConfig));
        });
        this.numLevels = this.levels.length;
        hnmLog(`HS_V5_TFJS: Initialization complete. ${this.levels.length} levels created.`);
    }

    getInitialStates() {
        if (this.isDisposed) throw new Error(`HNS is disposed.`);
        return this.levels.map(level => level.getInitialState());
    }

    step(currentBotLevelStates, currentBotLastStepOutputs, sensoryInputs, externalInputsAllSources = {}, detachNextStatesMemory = true) {
        if (this.isDisposed) throw new Error(`HNS is disposed.`);

        const nextBotLevelStatesList = new Array(this.numLevels).fill(null);
        const newlyRetrievedValuesForAllLevelsDict = {};
        const stepAnomalies = {}; const stepWeightChanges = {};
        const stepBuNorms = {}; const stepTdNorms = {}; const stepExternalNorms = {};
        const currentStepIntermediateOutputs = {};

        for (let i = 0; i < this.numLevels; i++) {
            const lvlMgr = this.levels[i]; const cfg = this.levelConfigsOriginal[i];
            const lvlName = cfg.name; const buSrcNames = cfg.bu_source_level_names || []; const tdSrcNames = cfg.td_source_level_names || [];
            const currentLevelSpecificState = currentBotLevelStates[i];
            const lvlBuIn = {}; const lvlTdIn = {};

            if (buSrcNames.length === 0) { // This is a root sensory level
                const rawSensoryDim = cfg.raw_sensory_input_dim; // The dim this level expects for its raw sensory input
                const sensoryInputTensor = sensoryInputs[lvlName]; // Get the tensor for this specific level

                if (sensoryInputTensor && !sensoryInputTensor.isDisposed &&
                    sensoryInputTensor.shape && sensoryInputTensor.shape.length === 3 && // Expect [1,1,dim]
                    sensoryInputTensor.shape[0] === 1 && sensoryInputTensor.shape[1] === 1 &&
                    sensoryInputTensor.shape[2] === rawSensoryDim) {
                    lvlBuIn[lvlName] = sensoryInputTensor; // Keyed by its own name for sensory input
                } else {
                    if(lvlMgr.nmmParams.verbose) hnmLog(`Warning: Sensory input for ${lvlName} is invalid or missing. Using zeros. Expected shape [1,1,${rawSensoryDim}], got ${sensoryInputTensor?.shape}`, "warn");
                    lvlBuIn[lvlName] = tf.keep(tf.zeros([1, 1, rawSensoryDim]));
                }
            } else { // This level gets BU input from other levels' current step outputs
                buSrcNames.forEach(srcName => {
                    const buSourceOutput = currentStepIntermediateOutputs[srcName]; // Output from a previous level *in this same step*
                    if (buSourceOutput && !buSourceOutput.isDisposed) { lvlBuIn[srcName] = buSourceOutput; }
                    else {
                        hnmLog(`Warning: Missing BU source output from '${srcName}' for level '${lvlName}' in current step. Using zeros.`, "warn");
                        lvlBuIn[srcName] = tf.keep(tf.zeros([1, 1, this.dims[srcName]]));
                    }
                });
            }

            // TD inputs come from *last* step's outputs of higher levels
            tdSrcNames.forEach(srcName => {
                const tdSourceOutput = currentBotLastStepOutputs[srcName]?.retrievedVal; // From HNM's previous full pass
                if (tdSourceOutput && !tdSourceOutput.isDisposed) { lvlTdIn[srcName] = tdSourceOutput; }
                else { // If TD signal is missing, provide zeros
                    lvlTdIn[srcName] = tf.keep(tf.zeros([1, 1, this.dims[srcName]]));
                }
            });

            // External input for this specific NMM
            let lvlExtInForNMMStep = null;
            const expectedExternal = this.level_expected_external_details[i]; // {name, dim} this NMM expects
            if (expectedExternal && expectedExternal.name && expectedExternal.dim > 0) {
                const providedSignal = externalInputsAllSources[expectedExternal.name];
                if (providedSignal && !providedSignal.isDisposed && providedSignal.shape &&
                    providedSignal.shape.length === 3 && providedSignal.shape[0] === 1 &&
                    providedSignal.shape[1] === 1 && providedSignal.shape[2] === expectedExternal.dim) {
                    lvlExtInForNMMStep = providedSignal;
                } else {
                    if(lvlMgr.nmmParams.verbose) hnmLog(`Warning for ${lvlName}: External signal '${expectedExternal.name}' invalid or missing from externalInputsAllSources. Using zeros. Expected dim ${expectedExternal.dim}, got ${providedSignal?.shape}`, "warn");
                    lvlExtInForNMMStep = tf.keep(tf.zeros([1,1,expectedExternal.dim]));
                }
            }

            const nmmOutputs = lvlMgr.forwardStep(lvlBuIn, lvlTdIn, currentLevelSpecificState, lvlExtInForNMMStep, detachNextStatesMemory);

            nextBotLevelStatesList[i] = nmmOutputs.nextState;
            currentStepIntermediateOutputs[lvlName] = tf.keep(nmmOutputs.retrievedVal.clone()); // This level's output for current step
            newlyRetrievedValuesForAllLevelsDict[lvlName] = nmmOutputs.retrievedVal; // For the final HNS output dict

            stepAnomalies[lvlName] = nmmOutputs.anomalyScore;
            stepWeightChanges[lvlName] = nmmOutputs.weightChange;
            stepBuNorms[lvlName] = nmmOutputs.buNorm;
            stepTdNorms[lvlName] = nmmOutputs.tdNorm;
            stepExternalNorms[lvlName] = nmmOutputs.extNorm;

            Object.entries(lvlBuIn).forEach(([key, t]) => { if (t !== sensoryInputs[lvlName] && t !== currentStepIntermediateOutputs[key] && t.rank === 3 && t.shape[0] === 1 && !t.isDisposed && t.dataSync().every(v => v ===0) ) t.dispose(); });
            Object.entries(lvlTdIn).forEach(([key, t]) => { if (t !== currentBotLastStepOutputs[key]?.retrievedVal && t.rank === 3 && t.shape[0] === 1 && !t.isDisposed && t.dataSync().every(v => v ===0) ) t.dispose(); });
            if (lvlExtInForNMMStep && lvlExtInForNMMStep !== externalInputsAllSources[expectedExternal?.name] && lvlExtInForNMMStep.rank === 3 && lvlExtInForNMMStep.shape[0] === 1 && !lvlExtInForNMMStep.isDisposed && lvlExtInForNMMStep.dataSync().every(v => v ===0) ) lvlExtInForNMMStep.dispose();
        }

        Object.values(currentStepIntermediateOutputs).forEach(t => { if (t && !t.isDisposed) t.dispose(); });

        return { newlyRetrievedValues: newlyRetrievedValuesForAllLevelsDict, nextBotStates: nextBotLevelStatesList, anomalies: stepAnomalies, weightChanges: stepWeightChanges, buNorms: stepBuNorms, tdNorms: stepTdNorms, extNorms: stepExternalNorms };
    }

    dispose() {
        if (this.isDisposed) return;
        this.levels.forEach(l => {if (l && typeof l.dispose === 'function') l.dispose();});
        this.levels = []; this.isDisposed = true; hnmLog("HNS Disposed.");
    }
}
window.MemoryMLP_TFJS = MemoryMLP_TFJS; window.NMM_TD_V5_TFJS = NMM_TD_V5_TFJS; window.HierarchicalSystemV5_TFJS = HierarchicalSystemV5_TFJS;
window.createNeuralMemState = createNeuralMemState; window.memStateDetach = memStateDetach; window.disposeMemStateWeights = disposeMemStateWeights; window.disposeHnsResultsTensors = disposeHnsResultsTensors; window.hnmLog = hnmLog;
console.log("[HNM Core] Version 1.0.0 Loaded. Classes attached to window object.");
    </script>

    <script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.164.1/build/three.module.js",
            "three/addons/": "https://unpkg.com/three@0.164.1/examples/jsm/",
            "rapier3d-compat": "https://cdn.skypack.dev/@dimforge/rapier3d-compat",
            "lil-gui": "https://unpkg.com/lil-gui@0.19.1/dist/lil-gui.esm.js",
            "stats.js": "https://unpkg.com/three@0.164.1/examples/jsm/libs/stats.module.js"
        }
    }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import RAPIER_MODULE from 'rapier3d-compat';
        import GUI from 'lil-gui';
        import Stats from 'stats.js';

        if (typeof window.HierarchicalSystemV5_TFJS === 'undefined') {
            const err = "FATAL: hnm_core_v1.0.0.js not loaded. Check script tag.";
            document.getElementById('info').textContent = err; console.error(err); throw new Error(err);
        }
        String.prototype.hashCode = function() { var hash = 0, i, chr; if (this.length === 0) return hash; for (i = 0; i < this.length; i++) { chr = this.charCodeAt(i); hash = ((hash << 5) - hash) + chr; hash |= 0; } return hash; };

        let RAPIER, world, scene, camera, renderer, stats, gui, eventQueue, physicsLines = null;
        let player = { mesh: null, rigidBody: null, collider: null, armorSegmentLocalOffsets: [], isOnGround: false, health: 100, maxHealth: 100, autoBattleTargetVelocity: new THREE.Vector3(), autoBattleFaceEnemy: false, autoBattleTargetEnemyPos: new THREE.Vector3(), defeatTimestamp: 0 };
        let vine = { segments: [], joints: [] };
        let blades = [];
        let bciTargetWorldIndicatorMesh, crosshairEl;
        let enemies = [];
        const PLAYER_MAX_HEALTH = 100; const ENEMY_MAX_HEALTH_BASE = 50; const ENEMY_DAMAGE_BASE = 10; const BLADE_HIT_DAMAGE = 20;
        let gameOver = false;
        let playerDefeatedAndGameOver = false;
        let allEnemiesDefeatedAndPlayerAlive = false;
        let celebrationModeActive = false;
        let celebrationEndTime = 0;


        const HNM_SENSORY_INPUT_DIM = 37;
        const HNM_BCI_COMMAND_DIM = 4;
        const VINE_RULE_ACTION_DIM_PER_SEGMENT = 3;
        const BLADE_RULE_ACTION_DIM = 6; // Force(xyz) + Torque(xyz)

        let hnmVine, hnmBladesSystems = [];
        let hnmPredictedActions = { vine: null, blades: [] };
        let ruleBasedActions = { vine: null, blades: [] };

        const userInput = { mouseX: 0, mouseY: 0, click: false, moveForward: 0, moveBackward: 0, moveLeft: 0, moveRight: 0, jump: false, bciCommandTarget: new THREE.Vector3(), bciCommandTargetScreen: new THREE.Vector2(), bciCommandTargetLastScreen: new THREE.Vector2(), bciCoherence: 0.0, bciAction: false, cameraYaw: Math.PI, cameraPitch: 0.25, isPointerLocked: false, isBCIModeActive: false, isBCITouchAiming: false, bciTouchStart: {x:0, y:0}, bciTouchCurrent: {x:0, y:0}, isDirectControllingVine: false, directControlActionActive: false };
        const params = {
            gravity: -15.0, playerSpeed: 8.0, playerJumpForce: 9.0,
            vineSegmentLength: 0.5, vineSegmentRadius: 0.2, numVineSegments: 20,
            vineForceScale: 5.0, vineDamping: 0.1, vineArmorSpringK: 5.0, vineArmorDampingK: 0.1,
            bladeForceScale: 5.0, bladeTorqueScale: 0.1, numBlades: 10, bladeOrbitRadiusBase: 2.0, bladeOrbitSpeed: 2.0,
            bladeReEngageSpeedThreshold: 1.5, bladeReEngageBackupDist: 3.0,
            showRapierDebug: true, enableHNM: false,
            resetSimulation: () => initDemo(true),
            vineHnmLR: 0.00025, bladeHnmLR: 0.0003,
            bciTargetDistance: 50.0, mouseSensitivity: 0.0022,
            bciCoherenceBuildRate: 0.025, bciCoherenceDecayRate: 0.015, bciAimStabilityThreshold: 0.2,
            bciCoherenceBladeDeployThreshold: 0.35, bciCoherenceMinActionThreshold: 0.25,
            deployOneBlade: () => deployBlades(1), recallAllBlades: () => recallAllBladesFunction(),
            toggleDirectVineControl: () => { userInput.isDirectControllingVine = !userInput.isDirectControllingVine; updateInfoDisplay();},
            numEnemies: 100, autoBattleInfluence: 100,
            hnmTakesControlChance: 0,
            displayVineAnomalies: { L0: 0, L1: 0 }, displayBladeAnomaliesAvg: { L0: 0, L1: 0 },
        };
        class BCIEmulationProcessor { constructor(outputDim) { this.outputDim = outputDim; } process(currentInputState, currentBciTargetWorld) { return tf.tidy(() => { const commandStrength = currentInputState.bciCoherence; const vec = [currentBciTargetWorld.x * commandStrength, currentBciTargetWorld.y * commandStrength, currentBciTargetWorld.z * commandStrength, (currentInputState.bciAction && commandStrength >= params.bciCoherenceMinActionThreshold) ? 1.0 : 0.0 ]; while (vec.length < this.outputDim) vec.push(0.0); return tf.tensor1d(vec.slice(0, this.outputDim)).expandDims(0).expandDims(0); }); } }
        let bciProcessor = new BCIEmulationProcessor(HNM_BCI_COMMAND_DIM);
        let bciTargetWorld = new THREE.Vector3();

        async function setupTfBackend() { try { await tf.setBackend('webgl'); console.log("TF.js: Using WebGL backend."); tf.env().set('WEBGL_FORCE_F16_TEXTURES', true); tf.env().set('WEBGL_PACK', true); tf.env().set('WEBGL_CONV_IM2COL', false); tf.env().set('WEBGL_USE_SHAPES_UNIFORMS', true); } catch (e) { console.warn("TF.js: WebGL backend failed, trying WASM.", e); try { await tf.setBackend('wasm'); console.log("TF.js: Using WASM backend."); } catch (eWasm) { console.warn("TF.js: WASM backend failed, using CPU.", eWasm); await tf.setBackend('cpu'); console.log("TF.js: Using CPU backend."); } } await tf.ready(); console.log(`TF.js Ready. Active backend: ${tf.getBackend()}`); }
        async function main() { await setupTfBackend(); await RAPIER_MODULE.init(); RAPIER = RAPIER_MODULE; bciTargetWorldIndicatorMesh = document.getElementById('bci-target-world-indicator'); crosshairEl = document.getElementById('crosshair'); initGraphics(); initGUI(); initDemo(true); setupInputListeners(); animate(); updateInfoDisplay(); }
        function definePlayerArmorOffsets() { player.armorSegmentLocalOffsets = []; const playerCapsuleRadius = 0.4; const playerCapsuleHalfHeight = 0.4; const armorRadius = playerCapsuleRadius + 0.15; const spirals = 2.2; const verticalSpreadFactor = 0.9; for (let i = 0; i < params.numVineSegments; i++) { const t = i / Math.max(1, params.numVineSegments -1); const yOffset = (t - 0.5) * (playerCapsuleHalfHeight * 2 * verticalSpreadFactor); const angle = (i * Math.PI * 2 * spirals) / params.numVineSegments + (Math.PI / params.numVineSegments * (i%2)); player.armorSegmentLocalOffsets.push(new THREE.Vector3(Math.cos(angle) * armorRadius, yOffset, Math.sin(angle) * armorRadius)); } }
        function initGraphics() { scene = new THREE.Scene(); scene.fog = new THREE.Fog(0x1a1a1a, 20, 70); camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.1, 1000); renderer = new THREE.WebGLRenderer({ antialias: true, canvas: document.querySelector('canvas') || createCanvasElement() }); renderer.setSize(window.innerWidth, window.innerHeight); renderer.setPixelRatio(window.devicePixelRatio); renderer.shadowMap.enabled = true; if (!document.querySelector('canvas')) document.body.appendChild(renderer.domElement); scene.add(new THREE.AmbientLight(0x606070)); const dirLight = new THREE.DirectionalLight(0xffffff, 1.5); dirLight.position.set(15, 25, 12); dirLight.castShadow = true; dirLight.shadow.mapSize.width = 1024; dirLight.shadow.mapSize.height = 1024; dirLight.shadow.camera.near = 0.5; dirLight.shadow.camera.far = 100; dirLight.shadow.camera.left = -30; dirLight.shadow.camera.right = 30; dirLight.shadow.camera.top = 30; dirLight.shadow.camera.bottom = -30; scene.add(dirLight); stats = new Stats(); document.getElementById('stats-container').appendChild(stats.dom); window.addEventListener('resize', onWindowResize); }
        function createCanvasElement() { const canvas = document.createElement('canvas'); document.body.insertBefore(canvas, document.body.firstChild); return canvas; }
        function onWindowResize() { camera.aspect = window.innerWidth / window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); }
        function initGUI() {
            gui = new GUI({ title: "HNM Vine/Blades Controls", autoPlace: true });
            gui.add(params, 'gravity', -30, 0, 0.1).name('Gravity Y').onChange(v => { if(world) world.gravity.y = v;});
            gui.add(params, 'playerSpeed', 1, 20, 0.1); gui.add(params, 'playerJumpForce', 1, 20, 0.1);
            gui.add(params, 'mouseSensitivity', 0.0005, 0.005, 0.0001).name('Mouse Sensitivity');

            const vineFolder = gui.addFolder('Vine Config');
            vineFolder.add(params, 'numVineSegments', 1, 20, 1).name('Segments').onChange(() => initDemo(true));
            vineFolder.add(params, 'vineSegmentLength', 0.2, 1.0, 0.01).name('Seg Length').onChange(() => initDemo(true));
            vineFolder.add(params, 'vineSegmentRadius', 0.02, 0.2, 0.005).name('Seg Radius').onChange(() => initDemo(true));
            vineFolder.add(params, 'vineForceScale', 5, 200, 1).name('HNM Force Scale');
            vineFolder.add(params, 'vineDamping', 0.1, 15, 0.1).name('Rapier Damping');
            vineFolder.add(params, 'vineArmorSpringK', 5, 150, 1).name('Armor Spring K');
            vineFolder.add(params, 'vineArmorDampingK', 0.1, 15, 0.1).name('Armor Damping K');

            const bladesFolder = gui.addFolder('Blades Config');
            bladesFolder.add(params, 'numBlades', 1, 10, 1).name('Max Blades').onChange(() => initDemo(true));
            bladesFolder.add(params, 'bladeForceScale', 5, 200, 1).name('HNM Force Scale');
            bladesFolder.add(params, 'bladeTorqueScale', 0.01, 10, 0.01).name('HNM Torque Scale');
            bladesFolder.add(params, 'bladeOrbitRadiusBase', 1.0, 5.0, 0.1).name('Orbit Radius Base');
            bladesFolder.add(params, 'bladeOrbitSpeed', 0.1, 2.0, 0.05).name('Orbit Speed');
            bladesFolder.add(params, 'bladeReEngageSpeedThreshold', 0.1, 2.0, 0.05).name('Blade Re-Engage Min Speed');
            bladesFolder.add(params, 'bladeReEngageBackupDist', 0.5, 5.0, 0.1).name('Blade Re-Engage Backup Dist');
            bladesFolder.add(params, 'bciCoherenceBladeDeployThreshold', 0.0, 1.0, 0.01).name('Deploy Coherence Min');
            bladesFolder.add(params, 'deployOneBlade').name('Deploy One Blade');
            bladesFolder.add(params, 'recallAllBlades').name('Recall All Blades (Manual)');

            const bciFolder = gui.addFolder('BCI Emulation');
            bciFolder.add(params, 'bciTargetDistance', 1, 50, 0.5).name('BCI Target Dist');
            bciFolder.add(params, 'bciCoherenceBuildRate', 0.001, 0.1, 0.001).name('Coherence Build');
            bciFolder.add(params, 'bciCoherenceDecayRate', 0.001, 0.1, 0.001).name('Coherence Decay');
            bciFolder.add(params, 'bciAimStabilityThreshold', 0.005, 0.2, 0.001).name('Aim Stability Thresh');
            bciFolder.add(params, 'bciCoherenceMinActionThreshold', 0.0, 1.0, 0.01).name('Min Coherence Action');

            const combatFolder = gui.addFolder('Combat Demo');
            combatFolder.add(params, 'numEnemies', 1, 100, 1).name('Number of Enemies').onChange(() => initDemo(true));
            combatFolder.add(params, 'autoBattleInfluence', 0, 100, 1).name('Auto-Battle Intent %');

            const hnmControlFolder = gui.addFolder('HNM Action & Stats');
            hnmControlFolder.add(params, 'enableHNM').name('Enable HNMs');
            hnmControlFolder.add(params, 'hnmTakesControlChance', 0, 100, 1).name('HNM Action Chance %');
            hnmControlFolder.add(params, 'vineHnmLR', 0.000, 0.005, 0.00005).name('Vine HNM LR').onChange(updateHnmLearningRates);
            hnmControlFolder.add(params, 'bladeHnmLR', 0.000, 0.005, 0.00005).name('Blades HNM LR').onChange(updateHnmLearningRates);
            hnmControlFolder.add(params.displayVineAnomalies, 'L0').name('Vine L0 Anomaly').listen().disable();
            hnmControlFolder.add(params.displayVineAnomalies, 'L1').name('Vine L1 Anomaly').listen().disable();
            hnmControlFolder.add(params.displayBladeAnomaliesAvg, 'L0').name('Blades L0 Avg Anom').listen().disable();
            hnmControlFolder.add(params.displayBladeAnomaliesAvg, 'L1').name('Blades L1 Avg Anom').listen().disable();

            gui.add(params, 'toggleDirectVineControl').name('Toggle Direct Vine Ctrl');
            gui.add(params, 'showRapierDebug').name('Show Rapier Debug').onChange( () => { if (!params.showRapierDebug && physicsLines) { scene.remove(physicsLines); if(physicsLines.geometry) physicsLines.geometry.dispose(); if(physicsLines.material) physicsLines.material.dispose(); physicsLines = null; } });
            gui.add(params, 'resetSimulation').name('Full Reset Simulation');
        }
        function updateHnmLearningRates() {
            if (hnmVine && hnmVine.system && hnmVine.system.levels) { hnmVine.system.levels.forEach(level => { if (level.optimizer) level.optimizer.learningRate = params.vineHnmLR; level.nmmParams.learning_rate = params.vineHnmLR; }); }
            hnmBladesSystems.forEach(bladeHnm => { if (bladeHnm && bladeHnm.system && bladeHnm.system.levels) { bladeHnm.system.levels.forEach(level => { if (level.optimizer) level.optimizer.learningRate = params.bladeHnmLR; level.nmmParams.learning_rate = params.bladeHnmLR; }); } });
        }
        async function initHNMSystems() {
            await tf.ready(); const hnmGlobalSimConfig = { HNM_VERBOSE: false };
            if (hnmVine) { if (hnmVine.system && !hnmVine.system.isDisposed) hnmVine.system.dispose(); if (hnmVine.policyHead && typeof hnmVine.policyHead.dispose === 'function') hnmVine.policyHead.dispose(); }
            const VINE_L0_EXTERNAL_DIM = HNM_BCI_COMMAND_DIM + (params.numVineSegments * VINE_RULE_ACTION_DIM_PER_SEGMENT);
            const vineHLC = [ { name: "L0_Vine_Sensorimotor", dim: HNM_SENSORY_INPUT_DIM, raw_sensory_input_dim: HNM_SENSORY_INPUT_DIM, bu_source_level_names: [], td_source_level_names: ["L1_Vine_Context"], nmm_params: { learning_rate: params.vineHnmLR, external_signal_dim: VINE_L0_EXTERNAL_DIM, external_signal_role: "add_to_target" }, external_input_config: { source_signal_name: "VineL0CombinedSignal", dim: VINE_L0_EXTERNAL_DIM } }, { name: "L1_Vine_Context", dim: HNM_SENSORY_INPUT_DIM * 2, bu_source_level_names: ["L0_Vine_Sensorimotor"], td_source_level_names: [], nmm_params: { learning_rate: params.vineHnmLR, mem_model_depth: 3, mem_model_expansion: 1.5 } } ];
            hnmVine = { system: new HierarchicalSystemV5_TFJS(vineHLC, hnmGlobalSimConfig), policyHeadInputLevelName: "L1_Vine_Context" };
            hnmVine.memoryState = hnmVine.system.getInitialStates(); hnmVine.lastStepOutputs = {}; hnmVine.system.levelConfigsOriginal.forEach(lc => { hnmVine.lastStepOutputs[lc.name] = { retrievedVal: tf.keep(tf.zeros([1, 1, lc.dim])) }; });
            const vinePolicyInputDim = hnmVine.system.dims[hnmVine.policyHeadInputLevelName];
            hnmVine.policyHead = tf.sequential({ name: "VinePolicy" }); hnmVine.policyHead.add(tf.layers.dense({ units: 64, inputShape: [vinePolicyInputDim], activation:'relu'})); hnmVine.policyHead.add(tf.layers.dense({ units: params.numVineSegments * VINE_RULE_ACTION_DIM_PER_SEGMENT, activation: 'tanh' }));
            hnmBladesSystems.forEach(existingHnm => { if(existingHnm) { if (existingHnm.system && !existingHnm.system.isDisposed) existingHnm.system.dispose(); if (existingHnm.policyHead && typeof existingHnm.policyHead.dispose === 'function') existingHnm.policyHead.dispose(); } }); hnmBladesSystems = [];
            const BLADE_L0_EXTERNAL_DIM = HNM_BCI_COMMAND_DIM + BLADE_RULE_ACTION_DIM;
            const bladeHLC_template = [ { name: "L0_Blade_Sensorimotor", dim: HNM_SENSORY_INPUT_DIM, raw_sensory_input_dim: HNM_SENSORY_INPUT_DIM, bu_source_level_names: [], td_source_level_names: ["L1_Blade_Navigation"], nmm_params: { learning_rate: params.bladeHnmLR, external_signal_dim: BLADE_L0_EXTERNAL_DIM, external_signal_role: "add_to_target"}, external_input_config: {source_signal_name: "BladeL0CombinedSignal", dim: BLADE_L0_EXTERNAL_DIM}}, { name: "L1_Blade_Navigation", dim: HNM_SENSORY_INPUT_DIM * 2, bu_source_level_names: ["L0_Blade_Sensorimotor"], td_source_level_names: [], nmm_params: { learning_rate: params.bladeHnmLR, mem_model_depth:3, mem_model_expansion:1.5}} ];
            for (let i = 0; i < params.numBlades; ++i) {
                const bladeHNM = { system: new HierarchicalSystemV5_TFJS(JSON.parse(JSON.stringify(bladeHLC_template)), hnmGlobalSimConfig), policyHeadInputLevelName: "L1_Blade_Navigation" };
                bladeHNM.memoryState = bladeHNM.system.getInitialStates(); bladeHNM.lastStepOutputs = {}; bladeHNM.system.levelConfigsOriginal.forEach(lc => { bladeHNM.lastStepOutputs[lc.name] = { retrievedVal: tf.keep(tf.zeros([1, 1, lc.dim])) }; });
                const bladePolicyInputDim = bladeHNM.system.dims[bladeHNM.policyHeadInputLevelName];
                bladeHNM.policyHead = tf.sequential({name: `BladePolicy_${i}`}); bladeHNM.policyHead.add(tf.layers.dense({ units: 64, inputShape: [bladePolicyInputDim], activation:'relu'})); bladeHNM.policyHead.add(tf.layers.dense({ units: BLADE_RULE_ACTION_DIM, activation: 'tanh' })); hnmBladesSystems.push(bladeHNM);
            } updateHnmLearningRates();
        }
        function cleanupPhysicsAndScene() {
            if (player?.mesh) scene.remove(player.mesh); player.mesh = null;
            if (vine?.segments) { vine.segments.forEach(s => { if(s.mesh) scene.remove(s.mesh); s.mesh = null; }); } vine = { segments: [], joints: [] };
            blades.forEach(b => { if(b.mesh) scene.remove(b.mesh); b.mesh = null; }); enemies.forEach(e => { if(e.mesh) scene.remove(e.mesh); e.mesh = null; }); enemies = [];
            if (physicsLines) { scene.remove(physicsLines); if(physicsLines.geometry) physicsLines.geometry.dispose(); if(physicsLines.material) physicsLines.material.dispose(); physicsLines = null; }
            if (world) { world.free(); world = null; } if (player) { player.rigidBody = null; player.collider = null; }
        }
        function initDemo(fullReset = false) {
            console.log("Initializing Demo (Full Reset: " + fullReset + ")...");
            gameOver = false; playerDefeatedAndGameOver = false; allEnemiesDefeatedAndPlayerAlive = false; celebrationModeActive = false; celebrationEndTime = 0; player.defeatTimestamp = 0;
            cleanupPhysicsAndScene();
            const initTasks = async () => { if (fullReset) { definePlayerArmorOffsets(); await initHNMSystems(); } initPhysicsAndEntities(); resetAndKeepHNMStates(); updateInfoDisplay("Simulation " + (fullReset ? "Reset." : "Round Restarted.")); };
            initTasks().catch(err => { console.error("Error during initDemo tasks:", err); updateInfoDisplay("ERROR initializing demo!"); });
        }
        function resetAndKeepHNMStates() { [hnmVine, ...hnmBladesSystems].forEach(hnmController => { if (hnmController && hnmController.system && !hnmController.system.isDisposed) { if (hnmController.memoryState) { hnmController.memoryState.forEach(s => window.disposeMemStateWeights(s)); } hnmController.memoryState = hnmController.system.getInitialStates(); if (hnmController.lastStepOutputs) { Object.values(hnmController.lastStepOutputs).forEach(valObj => { if(valObj?.retrievedVal && !valObj.retrievedVal.isDisposed) valObj.retrievedVal.dispose();}); } hnmController.lastStepOutputs = {}; hnmController.system.levelConfigsOriginal.forEach(lc => { hnmController.lastStepOutputs[lc.name] = { retrievedVal: tf.keep(tf.zeros([1, 1, lc.dim])) }; }); } else if (hnmController) { console.warn("Attempted to reset HNM state, but HNM system was invalid or disposed."); } }); }
        function initPhysicsAndEntities() {
            world = new RAPIER.World({ x: 0, y: params.gravity, z: 0 }); eventQueue = new RAPIER.EventQueue(true);
            const groundColliderDesc = RAPIER.ColliderDesc.cuboid(500, 0.1, 500).setTranslation(0,-0.1,0).setFriction(1.0); world.createCollider(groundColliderDesc);
            const playerMat = new THREE.MeshStandardMaterial({ color: 0x33dd33, emissive: 0x113311, roughness: 0.6, metalness: 0.2 });
            player.mesh = new THREE.Mesh(new THREE.CapsuleGeometry(0.4, 0.8, 4, 8), playerMat); player.mesh.castShadow = true;
            const playerBodyDesc = RAPIER.RigidBodyDesc.dynamic().setTranslation(0, 2.0, 0).setCanSleep(false).setLinearDamping(0.8).setAngularDamping(Math.PI);
            player.rigidBody = world.createRigidBody(playerBodyDesc); player.collider = world.createCollider(RAPIER.ColliderDesc.capsule(0.4, 0.4), player.rigidBody);
            player.rigidBody.lockRotations(true, true); player.collider.setActiveEvents(RAPIER.ActiveEvents.COLLISION_EVENTS); player.rigidBody.userData = {entityType: "player", entityId: "player_0"}; scene.add(player.mesh);
            player.isOnGround = false; player.health = PLAYER_MAX_HEALTH; player.maxHealth = PLAYER_MAX_HEALTH; player.autoBattleTargetVelocity = new THREE.Vector3(); player.autoBattleFaceEnemy = false; player.autoBattleTargetEnemyPos = new THREE.Vector3(); player.defeatTimestamp = 0;
            vine = { segments: [], joints: [] }; let prevBody = player.rigidBody; let attachPointOnPrev = { x: 0, y: -0.4, z: 0 };
            for (let i = 0; i < params.numVineSegments; i++) {
                const playerWorldPos = player.rigidBody.translation(); const playerWorldRot = player.rigidBody.rotation();
                const localOffset = player.armorSegmentLocalOffsets[i] || new THREE.Vector3(0, -(i+1)*params.vineSegmentLength, 0);
                const targetWorldPos = new THREE.Vector3(localOffset.x, localOffset.y, localOffset.z).applyQuaternion(new THREE.Quaternion(playerWorldRot.x, playerWorldRot.y, playerWorldRot.z, playerWorldRot.w)).add(new THREE.Vector3(playerWorldPos.x, playerWorldPos.y, playerWorldPos.z));
                const segMat = new THREE.MeshStandardMaterial({ color: 0x774411, emissive:0x110500, roughness:0.7, metalness: 0.1});
                const seg = { mesh: new THREE.Mesh(new THREE.CylinderGeometry(params.vineSegmentRadius, params.vineSegmentRadius, params.vineSegmentLength, 6), segMat), id: `vineSeg_${i}` };
                seg.mesh.castShadow = true; const segBodyDesc = RAPIER.RigidBodyDesc.dynamic().setTranslation(targetWorldPos.x, targetWorldPos.y, targetWorldPos.z).setCanSleep(false).setLinearDamping(params.vineDamping).setAngularDamping(params.vineDamping);
                seg.rigidBody = world.createRigidBody(segBodyDesc); seg.collider = world.createCollider(RAPIER.ColliderDesc.capsule(params.vineSegmentLength / 2.0 - params.vineSegmentRadius, params.vineSegmentRadius).setDensity(0.1).setFriction(0.7), seg.rigidBody);
                scene.add(seg.mesh); vine.segments.push(seg);
                const attachPointOnSeg = { x: 0, y: params.vineSegmentLength / 2, z: 0 }; const jointData = RAPIER.JointData.spherical(attachPointOnPrev, attachPointOnSeg);
                const joint = world.createImpulseJoint(jointData, prevBody, seg.rigidBody, true); joint.setContactsEnabled(false); vine.joints.push(joint);
                prevBody = seg.rigidBody; attachPointOnPrev = { x: 0, y: -params.vineSegmentLength / 2, z: 0 };
            }
            const bladeMat = new THREE.MeshStandardMaterial({ color: 0xb8b8d1, metalness: 0.95, roughness: 0.2, emissive: 0x101020}); const newBladesArray = [];
            for (let i = 0; i < params.numBlades; ++i) { const newBlade = { id: `blade_${i}`, mesh: new THREE.Mesh(new THREE.BoxGeometry(0.7, 0.08, 0.15), bladeMat), rigidBody: null, collider: null, isStored: true, hnm: hnmBladesSystems[i], state: {} }; newBlade.mesh.castShadow = true; newBlade.mesh.visible = false; scene.add(newBlade.mesh); newBladesArray.push(newBlade); } blades = newBladesArray;
            enemies = []; const enemyMaterial = new THREE.MeshStandardMaterial({ color: 0xff6666, emissive: 0x441111, roughness:0.8 }); const flyingEnemyMaterial = new THREE.MeshStandardMaterial({ color: 0xffaa33, emissive: 0x553300, roughness:0.7 });
            for (let i = 0; i < params.numEnemies; i++) {
                const level = Math.floor(Math.random() * 3) + 1; const size = 0.5 + level * 0.15; const enemyMaxHealth = ENEMY_MAX_HEALTH_BASE + (level - 1) * 25; const enemyDamage = ENEMY_DAMAGE_BASE + (level - 1) * 5; const isFlyingEnemy = Math.random() < 0.4;
                const enemyMesh = new THREE.Mesh(new THREE.SphereGeometry(size, 12, 8), isFlyingEnemy ? flyingEnemyMaterial : enemyMaterial); enemyMesh.castShadow = true;
                const spawnX = (Math.random() - 0.5) * 20; const spawnZ = (Math.random() - 0.5) * 20; let enemyBodyDesc; let spawnY = size;
                if (isFlyingEnemy) { spawnY = size + 2.0 + Math.random() * 2.0; enemyBodyDesc = RAPIER.RigidBodyDesc.kinematicVelocityBased().setTranslation(spawnX, spawnY, spawnZ).setCanSleep(false);
                } else { enemyBodyDesc = RAPIER.RigidBodyDesc.dynamic().setTranslation(spawnX, spawnY, spawnZ).setCanSleep(false).setLinearDamping(0.5).setAngularDamping(0.5); }
                const enemyBody = world.createRigidBody(enemyBodyDesc); const enemyCollider = world.createCollider(RAPIER.ColliderDesc.ball(size).setDensity(0.8), enemyBody);
                enemyCollider.setActiveEvents(RAPIER.ActiveEvents.COLLISION_EVENTS); const enemyId = `enemy_${i}_lvl${level}${isFlyingEnemy ? '_fly' : ''}`; enemyBody.userData = { entityType: "enemy", entityId: enemyId, level: level, isFlying: isFlyingEnemy };
                enemies.push({ id: enemyId, mesh: enemyMesh, rigidBody: enemyBody, collider: enemyCollider, health: enemyMaxHealth, maxHealth: enemyMaxHealth, damage: enemyDamage, level: level, isFlying: isFlyingEnemy, attackCooldown: 0, targetPlayer: true }); scene.add(enemyMesh);
            } updateHealthUIDisplay();
        }
        function updateEnemies(deltaTime) {
             if (playerDefeatedAndGameOver) {
                const timeSinceDefeat = performance.now() - (player.defeatTimestamp || 0);
                if (timeSinceDefeat > 3000) { // 3 seconds after defeat
                    enemies.forEach(enemy => {
                        if (enemy.rigidBody) {
                            enemy.rigidBody.setLinvel({x:0, y: enemy.isFlying ? 0 : enemy.rigidBody.linvel().y, z:0}, true);
                            enemy.rigidBody.setAngvel({x:0, y:0, z:0}, true);
                        }
                    });
                    return; // Don't update enemy movement further
                }
                // Otherwise, continue normal enemy update logic (they will keep targeting player's last pos or current physics pos)
            } else if (allEnemiesDefeatedAndPlayerAlive && celebrationModeActive) {
                 enemies.forEach(enemy => { // Should be empty, but just in case
                    if (enemy.rigidBody) {
                        enemy.rigidBody.setLinvel({x:0, y: enemy.isFlying ? 0 : enemy.rigidBody.linvel().y, z:0}, true);
                        enemy.rigidBody.setAngvel({x:0, y:0, z:0}, true);
                    }
                });
                return;
            }


            const time = performance.now() * 0.001;
            enemies.forEach(enemy => {
                if (enemy.health <= 0 || !enemy.rigidBody || !player || !player.rigidBody) return;

                const enemyPos = enemy.rigidBody.translation();
                const playerPosVec = player.rigidBody.translation(); // This will be the physics body's current position

                if (enemy.isFlying) {
                    const targetFlyHeight = playerPosVec.y + 2.0 + Math.sin(time * 0.3 + enemy.id.hashCode() * 0.1) * 1.5;
                    const directionToPlayer3D = new THREE.Vector3(playerPosVec.x - enemyPos.x, targetFlyHeight - enemyPos.y, playerPosVec.z - enemyPos.z);
                    if (directionToPlayer3D.lengthSq() > 0.1) {
                        directionToPlayer3D.normalize();
                        const enemySpeed = 2.0 + enemy.level * 0.25;
                        enemy.rigidBody.setLinvel({ x: directionToPlayer3D.x * enemySpeed, y: directionToPlayer3D.y * enemySpeed, z: directionToPlayer3D.z * enemySpeed }, true);
                    }
                } else {
                    const directionToPlayer = new THREE.Vector3(playerPosVec.x - enemyPos.x, 0, playerPosVec.z - enemyPos.z);
                    if (directionToPlayer.lengthSq() > 0.1) {
                        directionToPlayer.normalize();
                        const enemySpeed = 3.0 + enemy.level * 0.5;
                        const currentYVel = enemy.rigidBody.linvel().y;
                        enemy.rigidBody.setLinvel({ x: directionToPlayer.x * enemySpeed, y: currentYVel, z: directionToPlayer.z * enemySpeed }, true);
                    }
                }
                if (enemy.attackCooldown > 0) {
                    enemy.attackCooldown -= deltaTime;
                }
            });
        }
        function handlePlayerDamage(amount, source = "unknown") {
            if (player.health <= 0 && playerDefeatedAndGameOver) return;

            player.health -= amount;
            updateInfoDisplay(`Player took ${amount} damage from ${source}! Health: ${player.health}`);
            updateHealthUIDisplay();

            if (player.health <= 0 && !playerDefeatedAndGameOver) {
                player.health = 0;
                player.defeatTimestamp = performance.now();
                gameOver = true;
                playerDefeatedAndGameOver = true;
                updateInfoDisplay("Player Defeated! Blades lose control. Training session will restart.");

                if (vine && vine.segments) {
                    vine.segments.forEach(seg => {
                        if (seg.rigidBody) {
                            const currentLinvel = seg.rigidBody.linvel();
                            seg.rigidBody.setLinvel({ x: 0, y: currentLinvel.y, z: 0 }, true);
                            seg.rigidBody.setAngvel({ x: 0, y: 0, z: 0 }, true);
                        }
                    });
                }
                blades.forEach(blade => {
                    if (!blade.isStored && blade.rigidBody) {
                        blade.rigidBody.setGravityScale(1.0, true);
                        blade.state.mode = "INERT";
                    }
                });
                setTimeout(() => initDemo(true), 4000);
            }
        }
        function handleEnemyDamage(enemyId, amount, source="unknown") {
            if (allEnemiesDefeatedAndPlayerAlive) return;
            const enemy = enemies.find(e => e.id === enemyId);
            if (enemy && enemy.health > 0) { enemy.health -= amount; updateInfoDisplay(`Enemy ${enemyId} took ${amount} damage from ${source}! Health: ${enemy.health}`); updateHealthUIDisplay();
                if (enemy.health <= 0) {
                    enemy.health = 0; updateInfoDisplay(`Enemy ${enemyId} defeated!`);
                    if (enemy.rigidBody) world.removeRigidBody(enemy.rigidBody);
                    if (enemy.mesh) scene.remove(enemy.mesh);
                    enemies = enemies.filter(e => e.id !== enemyId);

                    blades.forEach(blade => {
                        if (blade.state && blade.state.currentTargetInfo && blade.state.currentTargetInfo.id === enemyId) {
                            blade.state.currentTargetInfo = null;
                            blade.state.mode = 'ORBITING';
                            blade.state.noTargetTimer = 0;
                        }
                         if (blade.state && blade.state.lockedEnemyTargetId === enemyId) {
                            blade.state.lockedEnemyTargetId = null;
                            blade.state.isAggressivePursuit = false;
                         }
                    });

                    if (enemies.filter(e => e.health > 0).length === 0 && player.health > 0 && !allEnemiesDefeatedAndPlayerAlive) {
                        gameOver = true;
                        allEnemiesDefeatedAndPlayerAlive = true;
                        celebrationModeActive = true;
                        celebrationEndTime = performance.now() + 3000;
                        updateInfoDisplay("All enemies defeated! CELEBRATION! Training session will restart after.");
                    }
                }
            }
        }
        function updateHealthUIDisplay() {
            const playerHealthBarInner = document.querySelector('#player-health-bar .health-bar-inner'); if (playerHealthBarInner) playerHealthBarInner.style.width = `${(player.health / player.maxHealth) * 100}%`;
            const playerHealthValueEl = document.getElementById('player-health-value'); if(playerHealthValueEl) playerHealthValueEl.textContent = Math.max(0,Math.round(player.health));
            const enemiesContainer = document.getElementById('enemies-health-container'); if (!enemiesContainer) return; enemiesContainer.innerHTML = '';
            enemies.forEach(enemy => { if(enemy.health <= 0) return; const enemyHealthText = document.createElement('div'); enemyHealthText.textContent = `Enemy ${enemy.id.split('_')[1]}${(enemy.isFlying ? ' (Fly)' : '')} (Lvl ${enemy.level}) Health: ${Math.max(0,Math.round(enemy.health))}`; const enemyBarDiv = document.createElement('div'); enemyBarDiv.classList.add('health-bar'); const enemyBarInnerDiv = document.createElement('div'); enemyBarInnerDiv.classList.add('health-bar-inner'); if (enemy.isFlying) { enemyBarInnerDiv.classList.add('flying-enemy'); } else { enemyBarInnerDiv.classList.add('enemy'); } enemyBarInnerDiv.style.width = `${(enemy.health / enemy.maxHealth) * 100}%`; enemyBarDiv.appendChild(enemyBarInnerDiv); enemiesContainer.appendChild(enemyHealthText); enemiesContainer.appendChild(enemyBarDiv); });
        }
        function setupInputListeners() {
            const isTouchDevice = (('ontouchstart' in window) || (navigator.maxTouchPoints > 0) || (navigator.msMaxTouchPoints > 0)); const addSafeEventListener = (element, event, handler, options = {}) => { if(element) element.addEventListener(event, handler, options); else console.warn(`Element not found for listener: ${event}`); };
            if (isTouchDevice) {
                addSafeEventListener(document.getElementById('btn-forward'), 'touchstart', (e)=>{e.preventDefault();userInput.moveForward=1;}); addSafeEventListener(document.getElementById('btn-forward'), 'touchend', ()=>{userInput.moveForward=0;});
                addSafeEventListener(document.getElementById('btn-backward'), 'touchstart', (e)=>{e.preventDefault();userInput.moveBackward=1;}); addSafeEventListener(document.getElementById('btn-backward'), 'touchend', ()=>{userInput.moveBackward=0;});
                addSafeEventListener(document.getElementById('btn-left'), 'touchstart', (e)=>{e.preventDefault();userInput.moveLeft=1;}); addSafeEventListener(document.getElementById('btn-left'), 'touchend', ()=>{userInput.moveLeft=0;});
                addSafeEventListener(document.getElementById('btn-right'), 'touchstart', (e)=>{e.preventDefault();userInput.moveRight=1;}); addSafeEventListener(document.getElementById('btn-right'), 'touchend', ()=>{userInput.moveRight=0;});
                addSafeEventListener(document.getElementById('btn-jump'), 'touchstart', (e)=>{e.preventDefault();userInput.jump=true;});
                addSafeEventListener(document.getElementById('btn-bci-action'), 'touchstart', (e)=>{e.preventDefault();userInput.bciAction=true; if (userInput.isDirectControllingVine) userInput.directControlActionActive = true; }); addSafeEventListener(document.getElementById('btn-bci-action'), 'touchend', ()=>{userInput.bciAction=false; userInput.directControlActionActive = false;});
                const camSensitivity = 0.04; addSafeEventListener(document.getElementById('btn-cam-left'), 'touchstart', (e)=>{e.preventDefault();userInput.cameraYaw += camSensitivity;}); addSafeEventListener(document.getElementById('btn-cam-right'), 'touchstart', (e)=>{e.preventDefault();userInput.cameraYaw -= camSensitivity;});
                const bciToggleBtn = document.getElementById('btn-bci-target-toggle');
                addSafeEventListener(bciToggleBtn, 'touchstart', (e)=>{ e.preventDefault(); userInput.isBCITouchAiming = true; if(bciToggleBtn) bciToggleBtn.style.backgroundColor = 'rgba(150,150,80,0.8)'; if(e.touches.length > 0) { userInput.bciTouchStart.x = userInput.bciTouchCurrent.x = e.touches[0].clientX; userInput.bciTouchStart.y = userInput.bciTouchCurrent.y = e.touches[0].clientY; userInput.bciCommandTargetScreen.set(userInput.bciTouchStart.x / window.innerWidth, userInput.bciTouchStart.y / window.innerHeight); userInput.bciCommandTargetLastScreen.copy(userInput.bciCommandTargetScreen); } });
                addSafeEventListener(window, 'touchmove', (e)=>{ if(userInput.isBCITouchAiming && e.touches.length > 0){ for(let i=0; i<e.touches.length; ++i){ if(e.touches[i].target === bciToggleBtn || e.touches[i].target === renderer.domElement){ userInput.bciTouchCurrent.x = e.touches[i].clientX; userInput.bciTouchCurrent.y = e.touches[i].clientY; userInput.bciCommandTargetScreen.set(userInput.bciTouchCurrent.x / window.innerWidth, userInput.bciTouchCurrent.y / window.innerHeight); break;}}}}, {passive:false});
                addSafeEventListener(bciToggleBtn, 'touchend', ()=>{ userInput.isBCITouchAiming = false; if(bciToggleBtn) bciToggleBtn.style.backgroundColor = 'rgba(100,100,100,0.7)';});
                addSafeEventListener(document.getElementById('btn-deploy-blade'), 'click', () => deployBlades(1)); addSafeEventListener(document.getElementById('btn-recall-blades'), 'click', () => recallAllBladesFunction()); addSafeEventListener(document.getElementById('btn-direct-vine'), 'click', () => {userInput.isDirectControllingVine = !userInput.isDirectControllingVine; updateInfoDisplay(); });
            } else {
                addSafeEventListener(renderer.domElement, 'click', () => { if(!userInput.isPointerLocked) renderer.domElement.requestPointerLock(); });
                addSafeEventListener(document, 'pointerlockchange', () => { userInput.isPointerLocked = document.pointerLockElement === renderer.domElement; crosshairEl.style.display = userInput.isPointerLocked ? 'block' : 'none';}, false);
                addSafeEventListener(window, 'mousemove', (event) => { if (userInput.isPointerLocked) { userInput.cameraYaw -= event.movementX * params.mouseSensitivity; userInput.cameraPitch += event.movementY * params.mouseSensitivity; userInput.cameraPitch = Math.max(-Math.PI/2 + 0.1, Math.min(Math.PI/2 - 0.1, userInput.cameraPitch)); } if (userInput.isBCIModeActive) { userInput.bciCommandTargetScreen.set((event.clientX / window.innerWidth), (event.clientY / window.innerHeight)); } });
                addSafeEventListener(window, 'mousedown', (event) => { if (event.button === 0 && userInput.isBCIModeActive && event.ctrlKey) { event.preventDefault(); userInput.bciAction = true; if (userInput.isDirectControllingVine) userInput.directControlActionActive = true; }});
                addSafeEventListener(window, 'mouseup', (event) => { if (event.button === 0 && userInput.isBCIModeActive && event.ctrlKey) { event.preventDefault(); userInput.bciAction = false; userInput.directControlActionActive = false;} });
                addSafeEventListener(window, 'keydown', (event) => { if (event.repeat || playerDefeatedAndGameOver ) return; if (event.key.toLowerCase() === 'shift') userInput.isBCIModeActive = true; if (event.key.toLowerCase() === 'control' && userInput.isBCIModeActive) { userInput.bciAction = true; if (userInput.isDirectControllingVine) userInput.directControlActionActive = true;} if (event.key.toLowerCase() === 'v' && !event.ctrlKey && !event.shiftKey) { userInput.isDirectControllingVine = !userInput.isDirectControllingVine; updateInfoDisplay(); } if (event.key.toLowerCase() === '1' && !event.ctrlKey && !event.shiftKey) deployBlades(1); if (event.key.toLowerCase() === 'r' && !event.ctrlKey && !event.shiftKey) recallAllBladesFunction();
                    switch(event.key.toLowerCase()) { case 'w': userInput.moveForward = 1; break; case 's': userInput.moveBackward = 1; break; case 'a': userInput.moveLeft = 1; break; case 'd': userInput.moveRight = 1; break; case ' ': userInput.jump = true; event.preventDefault(); break; } });
                addSafeEventListener(window, 'keyup', (event) => { if (playerDefeatedAndGameOver) return; if (event.key.toLowerCase() === 'shift') { userInput.isBCIModeActive = false; if (!event.ctrlKey) {userInput.bciAction = false; userInput.directControlActionActive = false;}} if (event.key.toLowerCase() === 'control') { userInput.bciAction = false; userInput.directControlActionActive = false; if (!event.shiftKey) userInput.isBCIModeActive = false; }
                    switch(event.key.toLowerCase()) { case 'w': userInput.moveForward = 0; break; case 's': userInput.moveBackward = 0; break; case 'a': userInput.moveLeft = 0; break; case 'd': userInput.moveRight = 0; break; } });
            }
        }
        function updatePlayerPhysicsIntent() {
            if (!player || !player.rigidBody) return;

            const playerPhysicsPos = player.rigidBody.translation();
            const playerPhysicsLinvel = player.rigidBody.linvel();

            if (playerDefeatedAndGameOver) {
                player.rigidBody.resetForces(true);
                player.rigidBody.resetTorques(true);
                player.rigidBody.unlockRotations(true);
                // Allow gravity to affect, but no active control.
                // Player will naturally fall/slump based on Rapier physics.
                return;
            }
            player.rigidBody.setGravityScale(1.0, true);
            player.rigidBody.lockRotations(true, true);


            let finalMoveDirection = new THREE.Vector3();
            let yVel = playerPhysicsLinvel.y;
            const playerMoveDirection = new THREE.Vector3();
            const playerFlatForward = new THREE.Vector3(Math.sin(userInput.cameraYaw), 0, Math.cos(userInput.cameraYaw)).normalize();
            const playerRight = new THREE.Vector3().crossVectors(new THREE.Vector3(0, 1, 0), playerFlatForward).normalize();

            if (userInput.moveForward) playerMoveDirection.add(playerFlatForward);
            if (userInput.moveBackward) playerMoveDirection.sub(playerFlatForward);
            if (userInput.moveLeft) playerMoveDirection.add(playerRight);
            if (userInput.moveRight) playerMoveDirection.sub(playerRight);
            playerMoveDirection.normalize().multiplyScalar(params.playerSpeed);

            const autoBattleMoveDirection = player.autoBattleTargetVelocity.clone();
            finalMoveDirection.lerpVectors(playerMoveDirection, autoBattleMoveDirection, params.autoBattleInfluence / 100.0);

            const ray = new RAPIER.Ray(playerPhysicsPos, { x: 0, y: -1, z: 0 });
            const hit = world.castRay(ray, 0.65, true, RAPIER.QueryFilterFlags.EXCLUDE_SENSORS, undefined, player.collider);
            player.isOnGround = hit ? true : false;

            if (userInput.jump && player.isOnGround) {
                yVel = params.playerJumpForce;
                userInput.jump = false;
            }

            let newLinvel = { x: finalMoveDirection.x, y: yVel, z: finalMoveDirection.z };
            if (player.isOnGround && finalMoveDirection.lengthSq() < 0.01 && params.autoBattleInfluence < 50) {
                newLinvel.x = playerPhysicsLinvel.x * 0.1;
                newLinvel.z = playerPhysicsLinvel.z * 0.1;
            }
            player.rigidBody.setLinvel(newLinvel, true);

            if (params.autoBattleInfluence / 100.0 > 0.5 && player.autoBattleFaceEnemy && player.autoBattleTargetEnemyPos.lengthSq() > 0.001) {
                const directionToTarget = new THREE.Vector3().subVectors(player.autoBattleTargetEnemyPos, player.mesh.position);
                directionToTarget.y = 0;
                if (directionToTarget.lengthSq() > 0.001) {
                    const targetYaw = Math.atan2(directionToTarget.x, directionToTarget.z);
                    const visualRotationQuaternion = new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(0, 1, 0), targetYaw);
                    player.mesh.quaternion.slerp(visualRotationQuaternion, 0.15);
                }
            } else {
                const visualRotationQuaternion = new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(0, 1, 0), userInput.cameraYaw);
                player.mesh.quaternion.copy(visualRotationQuaternion);
            }
        }
        function getEntitySensoryData(entity, playerEntity, currentBciTargetWorld, entityType = "vine_segment", allBlades = []) {
            const pos = entity.rigidBody.translation(); const vel = entity.rigidBody.linvel(); const rot = entity.rigidBody.rotation(); const playerPos = playerEntity.rigidBody.translation(); const playerRot = playerEntity.rigidBody.rotation();
            const worldPosToPlayer = new THREE.Vector3(pos.x - playerPos.x, pos.y - playerPos.y, pos.z - playerPos.z); const playerInverseQuatTHREE = new THREE.Quaternion(playerRot.x, playerRot.y, playerRot.z, playerRot.w).invert(); const localPosRelToPlayer = worldPosToPlayer.clone().applyQuaternion(playerInverseQuatTHREE);
            const targetRelToEntity = new THREE.Vector3(currentBciTargetWorld.x - pos.x, currentBciTargetWorld.y - pos.y, currentBciTargetWorld.z - pos.z); const entityQuatTHREE = new THREE.Quaternion(rot.x, rot.y, rot.z, rot.w); const localTargetRelToEntity = targetRelToEntity.clone().applyQuaternion(entityQuatTHREE.clone().invert());
            const data = [ localPosRelToPlayer.x/5, localPosRelToPlayer.y/5, localPosRelToPlayer.z/5, vel.x/5, vel.y/5, vel.z/5, rot.x, rot.y, rot.z, rot.w, localTargetRelToEntity.x/10, localTargetRelToEntity.y/10, localTargetRelToEntity.z/10, userInput.bciCoherence, (userInput.bciAction && userInput.bciCoherence >= params.bciCoherenceMinActionThreshold) ? 1.0 : 0.0, playerEntity.rigidBody.linvel().x/5, playerEntity.rigidBody.linvel().y/5, playerEntity.rigidBody.linvel().z/5, entityType === "vine_segment" ? 1 : 0, entityType === "blade" ? 1 : 0, worldPosToPlayer.length() / 10.0, entity.rigidBody.isSleeping() ? 1.0 : 0.0, playerEntity.isOnGround ? 1.0 : 0.0, ];
            if (entityType === "blade") { let closestBladeDist = 100.0; let secondClosestBladeDist = 100.0; let numVisibleOtherBlades = 0; allBlades.forEach(otherBlade => { if (otherBlade.id !== entity.id && !otherBlade.isStored && otherBlade.rigidBody) { const otherPos = otherBlade.rigidBody.translation(); const dist = Math.sqrt((pos.x-otherPos.x)**2 + (pos.y-otherPos.y)**2 + (pos.z-otherPos.z)**2); numVisibleOtherBlades++; if (dist < closestBladeDist) { secondClosestBladeDist = closestBladeDist; closestBladeDist = dist; } else if (dist < secondClosestBladeDist) { secondClosestBladeDist = dist; } } }); data.push(Math.min(1.0, numVisibleOtherBlades / (params.numBlades -1 + 1e-6) )); data.push(closestBladeDist / 20.0); data.push(secondClosestBladeDist / 20.0);
            } else { data.push(0,0,0); }
            data.push(targetRelToEntity.x / 20.0, targetRelToEntity.y / 20.0, targetRelToEntity.z / 20.0);
            let nearestEnemyDist = 20.0; let nearestEnemyRelX = 0, nearestEnemyRelY = 0, nearestEnemyRelZ = 0;
            if (enemies.length > 0 && enemies[0].rigidBody && enemies[0].health > 0) { const enemy0Pos = enemies[0].rigidBody.translation(); const enemyRelPos = new THREE.Vector3(enemy0Pos.x - pos.x, enemy0Pos.y - pos.y, enemy0Pos.z - pos.z); nearestEnemyDist = enemyRelPos.length(); if(nearestEnemyDist > 0.01) enemyRelPos.normalize(); nearestEnemyRelX = enemyRelPos.x; nearestEnemyRelY = enemyRelPos.y; nearestEnemyRelZ = enemyRelPos.z; }
            data.push(nearestEnemyDist / 20.0); data.push(nearestEnemyRelX); data.push(nearestEnemyRelY); data.push(nearestEnemyRelZ);
            data.push(worldPosToPlayer.x / 10.0, worldPosToPlayer.y / 10.0, worldPosToPlayer.z / 10.0);
            data.push(params.autoBattleInfluence / 100.0);
            while(data.length < HNM_SENSORY_INPUT_DIM) data.push(Math.random()*0.01 - 0.005);
            return tf.tensor1d(data.slice(0, HNM_SENSORY_INPUT_DIM)).expandDims(0).expandDims(0);
        }
        function generateVineRuleActionVector(vineInstance, playerInstance, currentBciTargetWorld, currentBciCoherence, isBciActionActive) {
            const numSegments = params.numVineSegments; const ruleAction = new Array(numSegments * VINE_RULE_ACTION_DIM_PER_SEGMENT).fill(0.0);
            if (!playerInstance || !playerInstance.rigidBody || playerDefeatedAndGameOver) return tf.tensor1d(ruleAction).expandDims(0).expandDims(0);

            const playerPos = playerInstance.rigidBody.translation(); const playerWorldQuatTHREE = new THREE.Quaternion(playerInstance.rigidBody.rotation().x, playerInstance.rigidBody.rotation().y, playerInstance.rigidBody.rotation().z, playerInstance.rigidBody.rotation().w);
            const isManipulatorIntent = currentBciCoherence > 0.4 && isBciActionActive; const isDirectControlIntent = userInput.isDirectControllingVine && userInput.directControlActionActive;
            for (let i = 0; i < numSegments; i++) { const segment = vineInstance.segments[i]; if (!segment || !segment.rigidBody) continue; const segPos = segment.rigidBody.translation(); const segVel = segment.rigidBody.linvel(); let targetWorldPosForRule; let forceMagnitudeFactor = 0.6;
                if (isDirectControlIntent) { targetWorldPosForRule = currentBciTargetWorld.clone(); forceMagnitudeFactor = 1.0; } else if (isManipulatorIntent) { targetWorldPosForRule = currentBciTargetWorld.clone(); forceMagnitudeFactor = 0.75; } else { const localOffset = playerInstance.armorSegmentLocalOffsets[i]; targetWorldPosForRule = new THREE.Vector3(localOffset.x, localOffset.y, localOffset.z).applyQuaternion(playerWorldQuatTHREE).add(new THREE.Vector3(playerPos.x, playerPos.y, playerPos.z)); }
                const forceError = new THREE.Vector3().subVectors(targetWorldPosForRule, new THREE.Vector3(segPos.x, segPos.y, segPos.z)); const springK = isDirectControlIntent ? params.vineArmorSpringK * 1.5 : params.vineArmorSpringK; const dampingK = isDirectControlIntent ? params.vineArmorDampingK * 1.2 : params.vineArmorDampingK;
                const springForce = forceError.multiplyScalar(springK); const dampingForce = new THREE.Vector3(segVel.x, segVel.y, segVel.z).multiplyScalar(-dampingK); const totalForce = springForce.add(dampingForce);
                const maxComponent = Math.max(Math.abs(totalForce.x), Math.abs(totalForce.y), Math.abs(totalForce.z), 1.0);
                ruleAction[i * VINE_RULE_ACTION_DIM_PER_SEGMENT + 0] = THREE.MathUtils.clamp(totalForce.x / maxComponent, -1, 1) * forceMagnitudeFactor; ruleAction[i * VINE_RULE_ACTION_DIM_PER_SEGMENT + 1] = THREE.MathUtils.clamp(totalForce.y / maxComponent, -1, 1) * forceMagnitudeFactor; ruleAction[i * VINE_RULE_ACTION_DIM_PER_SEGMENT + 2] = THREE.MathUtils.clamp(totalForce.z / maxComponent, -1, 1) * forceMagnitudeFactor;
            } return tf.tensor1d(ruleAction).expandDims(0).expandDims(0);
        }

        function generateBladeRuleActionVector(bladeInstance, playerInstance, currentBciTargetWorld, currentBciCoherence, isBciActionActive, deltaTime, allEnemies) {
            const ruleAction = new Array(BLADE_RULE_ACTION_DIM).fill(0.0);
            if (!bladeInstance || bladeInstance.isStored || !bladeInstance.rigidBody || !playerInstance || !playerInstance.rigidBody ||
                bladeInstance.state.mode === "INERT" || playerDefeatedAndGameOver) {
                return tf.tensor1d(ruleAction).expandDims(0).expandDims(0);
            }

            const bladePosVec = bladeInstance.rigidBody.translation();
            const bladePos = new THREE.Vector3(bladePosVec.x, bladePosVec.y, bladePosVec.z);
            const playerPosVec = playerInstance.rigidBody.translation();
            const playerPos = new THREE.Vector3(playerPosVec.x, playerPosVec.y, playerPosVec.z);
            const bladeVelVec = bladeInstance.rigidBody.linvel();
            const bladeSpeed = Math.sqrt(bladeVelVec.x ** 2 + bladeVelVec.y ** 2 + bladeVelVec.z ** 2);

            const isBciAttackIntent = currentBciCoherence > params.bciCoherenceMinActionThreshold && isBciActionActive;
            let forceMagnitudeFactor = 0.6;
            let torqueMagnitudeFactor = 0.4;
            let effectiveTargetWorld = currentBciTargetWorld.clone();

            if (!bladeInstance.state) {
                 bladeInstance.state = { mode: 'ORBITING', currentTargetInfo: null, backupTimer: 0, aggressivePursuitTimer: 0, stuckTimer: 0, noTargetTimer: 0 };
            }
            bladeInstance.state.backupTimer = Math.max(0, bladeInstance.state.backupTimer - deltaTime);
            bladeInstance.state.aggressivePursuitTimer = Math.max(0, bladeInstance.state.aggressivePursuitTimer - deltaTime);

            if (celebrationModeActive) {
                bladeInstance.state.mode = 'CELEBRATING';
                const bladeIndex = blades.findIndex(b => b.id === bladeInstance.id);
                const activeBladesCount = Math.max(1, blades.filter(b => !b.isStored).length);
                const angleOffset = (bladeIndex * Math.PI * 2 / activeBladesCount) + performance.now() * 0.002 * params.bladeOrbitSpeed * 1.5;
                const orbitRadius = params.bladeOrbitRadiusBase * 0.8;
                effectiveTargetWorld.set( playerPos.x + Math.cos(angleOffset) * orbitRadius, playerPos.y + 1.2, playerPos.z + Math.sin(angleOffset) * orbitRadius );
                forceMagnitudeFactor = 0.7; torqueMagnitudeFactor = 1.0;
            } else if (bladeInstance.state.mode === 'BACKING_UP') {
                if (bladeInstance.state.backupTimer <= 0) { bladeInstance.state.mode = 'ORBITING'; bladeInstance.state.noTargetTimer = 0; }
                else { effectiveTargetWorld.copy(bladeInstance.state.backupTargetPos || playerPos); forceMagnitudeFactor = 0.8; torqueMagnitudeFactor = 0.3; }
            } else if (bladeInstance.state.mode === 'AGGRESSIVE_PURSUIT') {
                if (bladeInstance.state.aggressivePursuitTimer <= 0 || !bladeInstance.state.currentTargetInfo) {
                    bladeInstance.state.mode = 'ORBITING'; bladeInstance.state.noTargetTimer = 0; bladeInstance.state.currentTargetInfo = null;
                } else {
                    const currentTargetEnemy = allEnemies.find(e => e.id === bladeInstance.state.currentTargetInfo.id && e.health > 0 && e.rigidBody);
                    if (currentTargetEnemy) {
                        const enemyP = currentTargetEnemy.rigidBody.translation(); const enemyV = currentTargetEnemy.rigidBody.linvel(); const leadTime = 0.15;
                        effectiveTargetWorld.set(enemyP.x + enemyV.x * leadTime, enemyP.y + enemyV.y * leadTime, enemyP.z + enemyV.z * leadTime);
                        if(currentTargetEnemy.isFlying) effectiveTargetWorld.y = Math.max(0.5, Math.min(enemyP.y, playerPos.y + 2.5));
                        bladeInstance.state.currentTargetInfo.lastPos.copy(effectiveTargetWorld);
                    } else { bladeInstance.state.mode = 'ORBITING'; bladeInstance.state.noTargetTimer = 0; bladeInstance.state.currentTargetInfo = null; }
                    forceMagnitudeFactor = 1.0; torqueMagnitudeFactor = 0.8;
                }
            } else { // ORBITING or ATTACKING_TARGET (re-evaluation)
                bladeInstance.state.mode = 'ORBITING'; let foundTargetThisFrame = false;
                if (isBciAttackIntent) {
                    effectiveTargetWorld.copy(currentBciTargetWorld); bladeInstance.state.mode = 'ATTACKING_TARGET'; bladeInstance.state.noTargetTimer = 0; forceMagnitudeFactor = 0.9; torqueMagnitudeFactor = 0.7;
                    let enemyNearBci = null; let minDistToBciSq = (2.0)**2;
                    allEnemies.forEach(e => { if(e.health > 0 && e.rigidBody) { const enemyP = e.rigidBody.translation(); const distSq = currentBciTargetWorld.distanceToSquared(new THREE.Vector3(enemyP.x, enemyP.y, enemyP.z)); if (distSq < minDistToBciSq) { minDistToBciSq = distSq; enemyNearBci = e;}}});
                    if (enemyNearBci) {
                        bladeInstance.state.currentTargetInfo = { id: enemyNearBci.id, lastPos: new THREE.Vector3(enemyNearBci.rigidBody.translation().x, enemyNearBci.rigidBody.translation().y, enemyNearBci.rigidBody.translation().z) };
                        const enemyP = enemyNearBci.rigidBody.translation(); const enemyV = enemyNearBci.rigidBody.linvel(); const leadTime = 0.18;
                        effectiveTargetWorld.set(enemyP.x + enemyV.x * leadTime, enemyP.y + enemyV.y * leadTime, enemyP.z + enemyV.z * leadTime);
                        if(enemyNearBci.isFlying) effectiveTargetWorld.y = Math.max(0.5, Math.min(enemyP.y, playerPos.y + 2.5));
                        foundTargetThisFrame = true;
                    } else { bladeInstance.state.currentTargetInfo = null; }
                }

                if (!foundTargetThisFrame && params.autoBattleInfluence > 30 && allEnemies.length > 0) {
                    let closestEnemyForAuto = null; let minAutoDistSq = Infinity;
                    allEnemies.forEach(e => { if (e.health > 0 && e.rigidBody) { const enemyP = e.rigidBody.translation(); const distSq = bladePos.distanceToSquared(new THREE.Vector3(enemyP.x, enemyP.y, enemyP.z)); if (distSq < minAutoDistSq) { minAutoDistSq = distSq; closestEnemyForAuto = e;}}});
                    if (closestEnemyForAuto && minAutoDistSq < (params.bciTargetDistance * 0.8)**2 ) {
                        bladeInstance.state.mode = 'ATTACKING_TARGET'; bladeInstance.state.noTargetTimer = 0;
                        bladeInstance.state.currentTargetInfo = { id: closestEnemyForAuto.id, lastPos: new THREE.Vector3(closestEnemyForAuto.rigidBody.translation().x, closestEnemyForAuto.rigidBody.translation().y, closestEnemyForAuto.rigidBody.translation().z) };
                        const enemyP = closestEnemyForAuto.rigidBody.translation(); const enemyV = closestEnemyForAuto.rigidBody.linvel(); const leadTime = 0.2;
                        effectiveTargetWorld.set(enemyP.x + enemyV.x * leadTime, enemyP.y + enemyV.y * leadTime, enemyP.z + enemyV.z * leadTime);
                        if(closestEnemyForAuto.isFlying) effectiveTargetWorld.y = Math.max(0.5, Math.min(enemyP.y, playerPos.y + 2.5));
                        forceMagnitudeFactor = 0.8; torqueMagnitudeFactor = 0.6; foundTargetThisFrame = true;
                    }
                }
                // New logic: If orbiting and auto-battle is high, and no target yet, proactively pick one
                if (!foundTargetThisFrame && bladeInstance.state.mode === 'ORBITING' && params.autoBattleInfluence > 50 && bladeInstance.state.noTargetTimer > 1.5 && allEnemies.length > 0) {
                    let closestEnemyToBlade = null; let minBladeDistSq = Infinity;
                    allEnemies.forEach(e => { if (e.health > 0 && e.rigidBody) { const enemyP = e.rigidBody.translation(); const distSq = bladePos.distanceToSquared(new THREE.Vector3(enemyP.x, enemyP.y, enemyP.z)); if (distSq < minBladeDistSq) { minBladeDistSq = distSq; closestEnemyToBlade = e;}}});
                    if (closestEnemyToBlade && minBladeDistSq < (params.bciTargetDistance * 0.7)**2 ) {
                        bladeInstance.state.mode = 'ATTACKING_TARGET'; bladeInstance.state.noTargetTimer = 0;
                        bladeInstance.state.currentTargetInfo = { id: closestEnemyToBlade.id, lastPos: new THREE.Vector3(closestEnemyToBlade.rigidBody.translation().x, closestEnemyToBlade.rigidBody.translation().y, closestEnemyToBlade.rigidBody.translation().z) };
                        const enemyP = closestEnemyToBlade.rigidBody.translation(); const enemyV = closestEnemyToBlade.rigidBody.linvel(); const leadTime = 0.2;
                        effectiveTargetWorld.set(enemyP.x + enemyV.x * leadTime, enemyP.y + enemyV.y * leadTime, enemyP.z + enemyV.z * leadTime);
                         if(closestEnemyToBlade.isFlying) effectiveTargetWorld.y = Math.max(0.5, Math.min(enemyP.y, playerPos.y + 2.5));
                        forceMagnitudeFactor = 0.75; torqueMagnitudeFactor = 0.55; foundTargetThisFrame = true;
                    }
                }

                if (!foundTargetThisFrame) { // Default to orbiting if still no target
                    bladeInstance.state.mode = 'ORBITING'; bladeInstance.state.currentTargetInfo = null; bladeInstance.state.noTargetTimer += deltaTime;
                    const bladeIndex = blades.findIndex(b => b.id === bladeInstance.id); const activeBladesCount = Math.max(1, blades.filter(b => !b.isStored).length); const angleOffset = (bladeIndex * Math.PI * 2 / activeBladesCount) + performance.now() * 0.001 * params.bladeOrbitSpeed; const orbitRadius = params.bladeOrbitRadiusBase + (bladeIndex % 3) * 0.3; const orbitHeightVariation = (bladeIndex % 2 === 0) ? 0.2 : -0.1;
                    effectiveTargetWorld.set( playerPos.x + Math.cos(angleOffset) * orbitRadius, playerPos.y + 0.6 + orbitHeightVariation, playerPos.z + Math.sin(angleOffset) * orbitRadius );
                    forceMagnitudeFactor = 0.5; torqueMagnitudeFactor = 0.3;
                }

                if (bladeInstance.state.mode === 'ATTACKING_TARGET') {
                    const distToEffectiveTarget = bladePos.distanceTo(effectiveTargetWorld);
                    if (distToEffectiveTarget < params.bladeReEngageBackupDist * 0.6 && bladeSpeed < params.bladeReEngageSpeedThreshold * 0.8) { bladeInstance.state.stuckTimer += deltaTime; } else { bladeInstance.state.stuckTimer = 0; }
                    if (bladeInstance.state.stuckTimer > 1.2) {
                        bladeInstance.state.mode = 'BACKING_UP'; bladeInstance.state.backupTimer = 0.7; const awayFromTargetDir = new THREE.Vector3().subVectors(bladePos, effectiveTargetWorld).normalize();
                        bladeInstance.state.backupTargetPos = bladePos.clone().addScaledVector(awayFromTargetDir, params.bladeReEngageBackupDist * 0.5); effectiveTargetWorld.copy(bladeInstance.state.backupTargetPos); bladeInstance.state.stuckTimer = 0; bladeInstance.state.aggressivePursuitTimer = 0;
                    } else if (distToEffectiveTarget < params.bladeReEngageBackupDist * 0.3 && bladeSpeed < params.bladeReEngageSpeedThreshold * 0.5 && bladeInstance.state.aggressivePursuitTimer <=0) {
                         bladeInstance.state.mode = 'AGGRESSIVE_PURSUIT'; bladeInstance.state.aggressivePursuitTimer = 1.5;
                    }
                }
            }

            let dirToFinalTarget = new THREE.Vector3().subVectors(effectiveTargetWorld, bladePos); if (dirToFinalTarget.lengthSq() > 0.01) dirToFinalTarget.normalize(); else dirToFinalTarget.set(0, 0, 0);
            ruleAction[0] = dirToFinalTarget.x * forceMagnitudeFactor; ruleAction[1] = dirToFinalTarget.y * forceMagnitudeFactor; ruleAction[2] = dirToFinalTarget.z * forceMagnitudeFactor;
            const bladeRapierQuat = bladeInstance.rigidBody.rotation(); const bladeThreeQuat = new THREE.Quaternion(bladeRapierQuat.x, bladeRapierQuat.y, bladeRapierQuat.z, bladeRapierQuat.w); const currentForward = new THREE.Vector3(0, 0, 1).applyQuaternion(bladeThreeQuat);
            let lookAtDir;
            if (bladeInstance.state.mode === 'CELEBRATING') { lookAtDir = new THREE.Vector3(0,1,0); ruleAction[3] = 0; ruleAction[4] = 1.0 * torqueMagnitudeFactor; ruleAction[5] = 0; }
            else if (bladeInstance.state.mode === 'BACKING_UP') { lookAtDir = dirToFinalTarget; }
            else if (bladeInstance.state.mode === 'ATTACKING_TARGET' || bladeInstance.state.mode === 'AGGRESSIVE_PURSUIT') { lookAtDir = dirToFinalTarget; }
            else { lookAtDir = new THREE.Vector3().subVectors(playerPos, bladePos); if (lookAtDir.lengthSq() < 0.01) lookAtDir.set(0,0,1); else lookAtDir.normalize(); }
            if (bladeInstance.state.mode !== 'CELEBRATING') {
                const targetRotAxis = new THREE.Vector3().crossVectors(currentForward, lookAtDir); const angle = currentForward.angleTo(lookAtDir);
                if (angle > 0.05 && targetRotAxis.lengthSq() > 0.001) {
                    targetRotAxis.normalize(); const desiredAngVelStrength = (bladeInstance.state.mode === 'ATTACKING_TARGET' || bladeInstance.state.mode === 'AGGRESSIVE_PURSUIT') ? 2.8 : 1.8; const desiredAngVel = targetRotAxis.multiplyScalar(angle * desiredAngVelStrength); const currentAngVel = bladeInstance.rigidBody.angvel(); const torqueError = desiredAngVel.sub(new THREE.Vector3(currentAngVel.x, currentAngVel.y, currentAngVel.z));
                    ruleAction[3] = THREE.MathUtils.clamp(torqueError.x * torqueMagnitudeFactor, -1, 1); ruleAction[4] = THREE.MathUtils.clamp(torqueError.y * torqueMagnitudeFactor, -1, 1); ruleAction[5] = THREE.MathUtils.clamp(torqueError.z * torqueMagnitudeFactor, -1, 1);
                }
            }
            return tf.tensor1d(ruleAction).expandDims(0).expandDims(0);
        }

        function runHNMStepImplModified(hnmController, sensoryInputTensor, externalInputsMap = null) {
            if (!hnmController || !hnmController.system || !sensoryInputTensor || !params.enableHNM) { if (sensoryInputTensor && !sensoryInputTensor.isDisposed) sensoryInputTensor.dispose(); if (externalInputsMap) { Object.values(externalInputsMap).forEach(t => { if (t && !t.isDisposed) t.dispose(); }); } return { policyActions: null, anomalies: null }; }
            const hlc = hnmController.system.levelConfigsOriginal; const inputsForHNM = {};
            if (hlc[0] && (!hlc[0].bu_source_level_names || hlc[0].bu_source_level_names.length === 0) && hlc[0].raw_sensory_input_dim > 0) { inputsForHNM[hlc[0].name] = sensoryInputTensor; } else { if (sensoryInputTensor && !sensoryInputTensor.isDisposed) sensoryInputTensor.dispose(); }
            const externalSignalSourcesForSystemStep = {};
            if (externalInputsMap) { hnmController.system.level_expected_external_details.forEach((expectedDetail, levelIdx) => { const levelName = hnmController.system.levelConfigsOriginal[levelIdx].name; if (expectedDetail && expectedDetail.name && externalInputsMap[expectedDetail.name]) { const providedTensor = externalInputsMap[expectedDetail.name]; if (providedTensor && !providedTensor.isDisposed && providedTensor.shape && providedTensor.shape.length === 3 && providedTensor.shape[2] === expectedDetail.dim) { externalSignalSourcesForSystemStep[expectedDetail.name] = providedTensor; } else { console.warn(`HNM Step for ${levelName}: External signal ${expectedDetail.name} shape mismatch or invalid. Expected dim ${expectedDetail.dim}, got ${providedTensor?.shape}. Using zeros.`); externalSignalSourcesForSystemStep[expectedDetail.name] = tf.keep(tf.zeros([1, 1, expectedDetail.dim])); } } else if (expectedDetail && expectedDetail.name && expectedDetail.dim > 0) { externalSignalSourcesForSystemStep[expectedDetail.name] = tf.keep(tf.zeros([1, 1, expectedDetail.dim])); } }); }
            const lastOutputsForSystemStep = {}; for (const key in hnmController.lastStepOutputs) { const valObj = hnmController.lastStepOutputs[key]; if (valObj && valObj.retrievedVal && !valObj.retrievedVal.isDisposed) { lastOutputsForSystemStep[key] = { retrievedVal: tf.keep(valObj.retrievedVal.clone()) }; } else { const levelDim = hnmController.system.dims[key] || HNM_SENSORY_INPUT_DIM; lastOutputsForSystemStep[key] = { retrievedVal: tf.keep(tf.zeros([1, 1, levelDim])) }; } }
            const keptMemoryStates = hnmController.memoryState.map(state => window.memStateDetach(state));
            const hnmStepResult = hnmController.system.step(keptMemoryStates, lastOutputsForSystemStep, inputsForHNM, externalSignalSourcesForSystemStep, true);
            Object.values(lastOutputsForSystemStep).forEach(obj => { if (obj && obj.retrievedVal && !obj.retrievedVal.isDisposed) obj.retrievedVal.dispose(); }); keptMemoryStates.forEach(state => window.disposeMemStateWeights(state)); Object.values(externalSignalSourcesForSystemStep).forEach(t => { if(t && !t.isDisposed && t.dataSync().every(v=>v===0)) t.dispose()});
            hnmController.memoryState.forEach(state => window.disposeMemStateWeights(state)); hnmController.memoryState = hnmStepResult.nextBotStates;
            Object.values(hnmController.lastStepOutputs).forEach(valObj => { if (valObj?.retrievedVal && !valObj.retrievedVal.isDisposed) valObj.retrievedVal.dispose(); }); hnmController.lastStepOutputs = hnmStepResult.newlyRetrievedValues;
            const policyInputTensorDirect = hnmStepResult.newlyRetrievedValues[hnmController.policyHeadInputLevelName]?.retrievedVal; let policyOutputActionsArray = null;
            if (policyInputTensorDirect && !policyInputTensorDirect.isDisposed) { const policyOutputTensor = hnmController.policyHead.apply(policyInputTensorDirect.reshape([1, -1])); policyOutputActionsArray = policyOutputTensor.dataSync(); policyOutputTensor.dispose();
            } else { console.warn(`Policy input tensor for ${hnmController.policyHeadInputLevelName} was invalid. Using zero actions.`); const policyOutputLayer = hnmController.policyHead.layers[hnmController.policyHead.layers.length - 1]; policyOutputActionsArray = new Array(policyOutputLayer.units).fill(0.0); }
            const anomaliesToReturn = {}; if (hnmStepResult.anomalies) { for (const key in hnmStepResult.anomalies) { if (hnmStepResult.anomalies[key] && !hnmStepResult.anomalies[key].isDisposed) { anomaliesToReturn[key] = tf.keep(hnmStepResult.anomalies[key].clone()); } } }
            window.disposeHnsResultsTensors(hnmStepResult); return { policyActions: policyOutputActionsArray, anomalies: anomaliesToReturn };
        }
        function updateBCIAndHNMs(deltaTime) {
            if (!player || !player.rigidBody) return;

            if (!(allEnemiesDefeatedAndPlayerAlive && celebrationModeActive) && !playerDefeatedAndGameOver) {
                userInput.bciCoherence = Math.max(0.0, userInput.bciCoherence - params.bciCoherenceDecayRate * deltaTime * 60);
            }

            if (player.health > 0) { // Player alive, process their BCI inputs
                const playerPosVec = player.rigidBody.translation();
                const playerPos = new THREE.Vector3(playerPosVec.x, playerPosVec.y, playerPosVec.z);
                let playerRawBciTargetScreen = new THREE.Vector2(0,0);
                let playerIsActivelyBciAiming = false;
                let playerWantsBciActionThisFrame = false;

                if (userInput.isBCITouchAiming) {
                    playerRawBciTargetScreen.copy(userInput.bciCommandTargetScreen);
                    playerIsActivelyBciAiming = true;
                    playerWantsBciActionThisFrame = userInput.bciAction;
                } else if (userInput.isBCIModeActive) {
                    playerRawBciTargetScreen.copy(userInput.bciCommandTargetScreen);
                    playerIsActivelyBciAiming = true;
                    playerWantsBciActionThisFrame = userInput.bciAction;
                }

                const playerAimMovementDelta = playerRawBciTargetScreen.distanceTo(userInput.bciCommandTargetLastScreen);
                let tempPlayerCoherence = userInput.bciCoherence;
                if (playerIsActivelyBciAiming) {
                    if (playerWantsBciActionThisFrame) {
                        if (playerAimMovementDelta < params.bciAimStabilityThreshold) tempPlayerCoherence = Math.min(1.0, tempPlayerCoherence + params.bciCoherenceBuildRate * 2.5 * deltaTime * 60);
                        else tempPlayerCoherence = Math.min(1.0, tempPlayerCoherence + params.bciCoherenceBuildRate * 0.8 * deltaTime * 60);
                    } else {
                        if (playerAimMovementDelta < params.bciAimStabilityThreshold * 0.5) tempPlayerCoherence = Math.min(1.0, tempPlayerCoherence + params.bciCoherenceBuildRate * 0.5 * deltaTime * 60);
                        else tempPlayerCoherence = Math.max(0.0, tempPlayerCoherence - params.bciCoherenceDecayRate * 0.7 * deltaTime * 60);
                    }
                }
                userInput.bciCoherence = tempPlayerCoherence;

                let finalPlayerBciTargetWorld = new THREE.Vector3();
                if (playerIsActivelyBciAiming) {
                    const ndcPlayerTarget = new THREE.Vector3(playerRawBciTargetScreen.x * 2 - 1, -playerRawBciTargetScreen.y * 2 + 1, 0.5);
                    const unprojected = ndcPlayerTarget.unproject(camera);
                    finalPlayerBciTargetWorld.copy(camera.position).addScaledVector(unprojected.sub(camera.position).normalize(), params.bciTargetDistance);
                } else {
                    const playerForward = new THREE.Vector3(0,0,-1).applyQuaternion(player.mesh.quaternion);
                    finalPlayerBciTargetWorld.copy(playerPos).addScaledVector(playerForward, 4.0).add(new THREE.Vector3(0,0.5,0));
                }
                bciTargetWorld.copy(finalPlayerBciTargetWorld);
                userInput.bciAction = playerIsActivelyBciAiming && playerWantsBciActionThisFrame && (userInput.bciCoherence >= params.bciCoherenceMinActionThreshold);
                userInput.bciCommandTargetLastScreen.copy(playerRawBciTargetScreen);

            } else { // Player defeated
                 userInput.bciCoherence = 0;
                 userInput.bciAction = false;
            }

            let autoBattleBciTargetWorld = new THREE.Vector3().copy(bciTargetWorld);
            let autoBattleCoherenceContribution = 0.0;
            let autoBattleWantsActionContribution = false;

            if (params.autoBattleInfluence > 0 && !playerDefeatedAndGameOver && !(allEnemiesDefeatedAndPlayerAlive && celebrationModeActive) ) {
                player.autoBattleTargetVelocity.set(0,0,0); player.autoBattleFaceEnemy = false;
                if (enemies.filter(e => e.health > 0).length > 0) {
                    let closestEnemy = null; let minDistanceSq = Infinity;
                    const playerCurrentPos = player.rigidBody.translation();
                    enemies.forEach(enemy => {
                        if (enemy.rigidBody && enemy.health > 0) {
                            const enemyP = enemy.rigidBody.translation();
                            const distSq = (new THREE.Vector3(playerCurrentPos.x,playerCurrentPos.y,playerCurrentPos.z)).distanceToSquared(new THREE.Vector3(enemyP.x, enemyP.y, enemyP.z));
                            if (distSq < minDistanceSq) { minDistanceSq = distSq; closestEnemy = enemy; }
                        }
                    });
                    if (closestEnemy && closestEnemy.rigidBody) {
                        const enemyPosVec = closestEnemy.rigidBody.translation();
                        const enemyPosTHREE = new THREE.Vector3(enemyPosVec.x, enemyPosVec.y, enemyPosVec.z);
                        autoBattleBciTargetWorld.copy(enemyPosTHREE);
                        if (player.health > 0) {
                            player.autoBattleFaceEnemy = true;
                            player.autoBattleTargetEnemyPos.copy(enemyPosTHREE);
                            const distanceToEnemy = Math.sqrt(minDistanceSq);
                            const desiredDistance = params.bladeOrbitRadiusBase * 1.8;
                            const directionToEnemyWorld = new THREE.Vector3().subVectors(enemyPosTHREE, new THREE.Vector3(playerCurrentPos.x,playerCurrentPos.y,playerCurrentPos.z) );
                            if (!closestEnemy.isFlying) directionToEnemyWorld.y = 0;
                            if(directionToEnemyWorld.lengthSq() > 0.01) directionToEnemyWorld.normalize();
                            if (distanceToEnemy > desiredDistance + 0.5) player.autoBattleTargetVelocity.copy(directionToEnemyWorld).multiplyScalar(params.playerSpeed);
                            else if (distanceToEnemy < desiredDistance - 0.5) player.autoBattleTargetVelocity.copy(directionToEnemyWorld).multiplyScalar(-params.playerSpeed);
                            if (!closestEnemy.isFlying && Math.random() < 0.015 && player.isOnGround) userInput.jump = true;
                        }
                        autoBattleCoherenceContribution = 0.85;
                        autoBattleWantsActionContribution = true;
                        if (player.health > 0 && Math.sqrt(minDistanceSq) < params.bciTargetDistance * 0.95) {
                            const activeBladesCount = blades.filter(b => !b.isStored).length;
                            if (activeBladesCount < params.numBlades && Math.random() < 0.08 * (params.autoBattleInfluence/100)) deployBlades(1);
                        }
                    } else { autoBattleCoherenceContribution = 0.1; }
                } else { autoBattleCoherenceContribution = 0.05; }
            }

            const abInfluenceRatio = params.autoBattleInfluence / 100.0;
            if (player.health > 0) {
                bciTargetWorld.lerpVectors(bciTargetWorld, autoBattleBciTargetWorld, abInfluenceRatio);
                userInput.bciCoherence = THREE.MathUtils.lerp(userInput.bciCoherence, autoBattleCoherenceContribution, abInfluenceRatio);
                const playerWants = userInput.bciAction; const aiWants = autoBattleWantsActionContribution;
                if (playerWants && aiWants) userInput.bciAction = true;
                else if (playerWants) userInput.bciAction = (Math.random() < (1.0 - abInfluenceRatio));
                else if (aiWants) userInput.bciAction = (Math.random() < abInfluenceRatio);
                else userInput.bciAction = false;
            } else if (!playerDefeatedAndGameOver) { // Player KO, but game not fully over
                bciTargetWorld.copy(autoBattleBciTargetWorld);
                userInput.bciCoherence = autoBattleCoherenceContribution;
                userInput.bciAction = autoBattleWantsActionContribution;
            }


            if (userInput.bciCoherence > 0.05 && !playerDefeatedAndGameOver && !(allEnemiesDefeatedAndPlayerAlive && celebrationModeActive)) {
                bciTargetWorldIndicatorMesh.style.display = 'block';
                const screenPos = bciTargetWorld.clone().project(camera);
                bciTargetWorldIndicatorMesh.style.left = `${(screenPos.x * 0.5 + 0.5) * window.innerWidth}px`;
                bciTargetWorldIndicatorMesh.style.top = `${(-screenPos.y * 0.5 + 0.5) * window.innerHeight}px`;
                bciTargetWorldIndicatorMesh.style.opacity = userInput.bciCoherence * 0.7 + 0.15;
            } else { bciTargetWorldIndicatorMesh.style.display = 'none'; }

            if (vine.segments.length > 0) {
                const vineRuleTensor = generateVineRuleActionVector(vine, player, bciTargetWorld, userInput.bciCoherence, userInput.bciAction);
                ruleBasedActions.vine = vineRuleTensor.dataSync();
                vineRuleTensor.dispose();
            }
            blades.forEach((blade, index) => {
                if (!blade.isStored && blade.rigidBody) {
                    const bladeRuleTensor = generateBladeRuleActionVector(blade, player, bciTargetWorld, userInput.bciCoherence, userInput.bciAction, deltaTime, enemies);
                    ruleBasedActions.blades[index] = bladeRuleTensor.dataSync();
                    bladeRuleTensor.dispose();
                } else { ruleBasedActions.blades[index] = null; }
            });

            if (params.enableHNM && !playerDefeatedAndGameOver && !(allEnemiesDefeatedAndPlayerAlive && celebrationModeActive) ) {
                tf.tidy(() => {
                    const finalBciCommandTensorForHNM = bciProcessor.process(userInput, bciTargetWorld);
                    if (hnmVine && hnmVine.system && !hnmVine.system.isDisposed && vine.segments.length > 0) {
                        const representativeVineSegment = vine.segments[Math.floor(params.numVineSegments / 2)];
                        if (representativeVineSegment && representativeVineSegment.rigidBody) {
                            const vineSensoryData = getEntitySensoryData(representativeVineSegment, player, bciTargetWorld, "vine_segment", blades);
                            const vineRuleActionForHNMInput = tf.tensor1d(ruleBasedActions.vine || new Array(params.numVineSegments * VINE_RULE_ACTION_DIM_PER_SEGMENT).fill(0)).expandDims(0).expandDims(0);
                            const vineCombinedExternalInput = tf.concat([finalBciCommandTensorForHNM.clone(), vineRuleActionForHNMInput], 2);
                            const vineExtInputName = hnmVine.system.levelConfigsOriginal[0].external_input_config?.source_signal_name;
                            const vineExtInputs = vineExtInputName ? { [vineExtInputName]: vineCombinedExternalInput } : {};
                            const vineHnmResult = runHNMStepImplModified(hnmVine, vineSensoryData, vineExtInputs);
                            if (vineHnmResult) {
                                hnmPredictedActions.vine = vineHnmResult.policyActions;
                                if (vineHnmResult.anomalies) {
                                    params.displayVineAnomalies.L0 = vineHnmResult.anomalies.L0_Vine_Sensorimotor ? vineHnmResult.anomalies.L0_Vine_Sensorimotor.dataSync()[0] : 0;
                                    params.displayVineAnomalies.L1 = vineHnmResult.anomalies.L1_Vine_Context ? vineHnmResult.anomalies.L1_Vine_Context.dataSync()[0] : 0;
                                    Object.values(vineHnmResult.anomalies).forEach(t => { if (t && !t.isDisposed) t.dispose(); });
                                }
                            } else { hnmPredictedActions.vine = null;}
                        }
                    }
                    let totalBladeL0Anomaly = 0; let totalBladeL1Anomaly = 0; let activeBladeHnmCount = 0;
                    blades.forEach((blade, index) => {
                        if (!blade.isStored && blade.rigidBody && blade.state.mode !== "INERT" && hnmBladesSystems[index] && hnmBladesSystems[index].system && !hnmBladesSystems[index].system.isDisposed) {
                            const bladeSensoryData = getEntitySensoryData(blade, player, bciTargetWorld, "blade", blades);
                            const bladeRuleActionForHNMInput = tf.tensor1d(ruleBasedActions.blades[index] || new Array(BLADE_RULE_ACTION_DIM).fill(0)).expandDims(0).expandDims(0);
                            const bladeCombinedExternalInput = tf.concat([finalBciCommandTensorForHNM.clone(), bladeRuleActionForHNMInput], 2);
                            const bladeExtInputName = hnmBladesSystems[index].system.levelConfigsOriginal[0].external_input_config?.source_signal_name;
                            const bladeExtInputs = bladeExtInputName ? { [bladeExtInputName]: bladeCombinedExternalInput } : {};
                            const bladeHnmResult = runHNMStepImplModified(hnmBladesSystems[index], bladeSensoryData, bladeExtInputs);
                            if (bladeHnmResult) {
                                hnmPredictedActions.blades[index] = bladeHnmResult.policyActions;
                                if (bladeHnmResult.anomalies) {
                                    totalBladeL0Anomaly += bladeHnmResult.anomalies.L0_Blade_Sensorimotor ? bladeHnmResult.anomalies.L0_Blade_Sensorimotor.dataSync()[0] : 0;
                                    totalBladeL1Anomaly += bladeHnmResult.anomalies.L1_Blade_Navigation ? bladeHnmResult.anomalies.L1_Blade_Navigation.dataSync()[0] : 0;
                                    Object.values(bladeHnmResult.anomalies).forEach(t => { if (t && !t.isDisposed) t.dispose(); });
                                    activeBladeHnmCount++;
                                }
                            } else { hnmPredictedActions.blades[index] = null; }
                        } else { hnmPredictedActions.blades[index] = null;}
                    });
                    if (activeBladeHnmCount > 0) { params.displayBladeAnomaliesAvg.L0 = totalBladeL0Anomaly / activeBladeHnmCount; params.displayBladeAnomaliesAvg.L1 = totalBladeL1Anomaly / activeBladeHnmCount; }
                    else { params.displayBladeAnomaliesAvg.L0 = 0; params.displayBladeAnomaliesAvg.L1 = 0; }
                    finalBciCommandTensorForHNM.dispose();
                });
                if (params.enableHNM && (params.vineHnmLR > 0 || params.bladeHnmLR > 0)) {
                    tf.tidy(() => {
                        if (hnmVine && hnmVine.policyHead && ruleBasedActions.vine && hnmVine.lastStepOutputs) { const vineTeacherActionsTensor = tf.tensor1d(ruleBasedActions.vine); const vinePolicyInputState = hnmVine.lastStepOutputs[hnmVine.policyHeadInputLevelName]?.retrievedVal; if (vinePolicyInputState && !vinePolicyInputState.isDisposed) { const vinePolicyOptimizer = tf.train.adam(params.vineHnmLR); const lossFunction = () => { const policyPrediction = hnmVine.policyHead.apply(vinePolicyInputState.reshape([1, -1])); return tf.losses.meanSquaredError(vineTeacherActionsTensor.reshape([1, -1]), policyPrediction); }; const trainableVars = hnmVine.policyHead.trainableWeights.map(w => w.val); if (trainableVars.length > 0) { const { grads, value } = vinePolicyOptimizer.computeGradients(lossFunction, trainableVars); if (grads) { const clippedGrads = {}; let globalNormVal = 0; for (const varName in grads) { if (grads[varName]) { globalNormVal += tf.norm(grads[varName]).square().dataSync()[0]; } } globalNormVal = Math.sqrt(globalNormVal); const clipNorm = 1.0; const clipRatio = globalNormVal > clipNorm ? clipNorm / (globalNormVal + 1e-6) : 1.0; for (const varName in grads) { if (grads[varName]) { clippedGrads[varName] = grads[varName].mul(tf.scalar(clipRatio)); } } vinePolicyOptimizer.applyGradients(clippedGrads); Object.values(grads).forEach(grad => { if(grad) grad.dispose(); }); Object.values(clippedGrads).forEach(grad => { if(grad) grad.dispose(); }); } if (value) value.dispose(); } vinePolicyOptimizer.dispose(); } if (vineTeacherActionsTensor) vineTeacherActionsTensor.dispose(); }
                        hnmBladesSystems.forEach((bladeHnm, index) => { const blade = blades[index]; if (bladeHnm && bladeHnm.policyHead && ruleBasedActions.blades && ruleBasedActions.blades[index] && !blade.isStored && blade.state.mode !== "INERT" && bladeHnm.lastStepOutputs) { const bladeTeacherActionsTensor = tf.tensor1d(ruleBasedActions.blades[index]); const bladePolicyInputState = bladeHnm.lastStepOutputs[bladeHnm.policyHeadInputLevelName]?.retrievedVal; if (bladePolicyInputState && !bladePolicyInputState.isDisposed) { const bladePolicyOptimizer = tf.train.adam(params.bladeHnmLR); const lossFunction = () => { const policyPrediction = bladeHnm.policyHead.apply(bladePolicyInputState.reshape([1,-1])); return tf.losses.meanSquaredError(bladeTeacherActionsTensor.reshape([1,-1]), policyPrediction); }; const trainableVars = bladeHnm.policyHead.trainableWeights.map(w => w.val); if (trainableVars.length > 0) { const { grads, value } = bladePolicyOptimizer.computeGradients(lossFunction, trainableVars); if (grads) { const clippedGrads = {}; let globalNormVal = 0; for (const varName in grads) { if (grads[varName]) globalNormVal += tf.norm(grads[varName]).square().dataSync()[0]; } globalNormVal = Math.sqrt(globalNormVal); const clipNorm = 1.0; const clipRatio = globalNormVal > clipNorm ? clipNorm / (globalNormVal + 1e-6) : 1.0; for (const varName in grads) { if (grads[varName]) clippedGrads[varName] = grads[varName].mul(tf.scalar(clipRatio)); } bladePolicyOptimizer.applyGradients(clippedGrads); Object.values(grads).forEach(grad => { if(grad) grad.dispose(); }); Object.values(clippedGrads).forEach(grad => { if(grad) grad.dispose(); }); } if (value) value.dispose(); } bladePolicyOptimizer.dispose(); } if (bladeTeacherActionsTensor) bladeTeacherActionsTensor.dispose(); } });
                    });
                }
            } else {
                hnmPredictedActions.vine = null; hnmPredictedActions.blades = blades.map(() => null);
                params.displayVineAnomalies.L0 = 0; params.displayVineAnomalies.L1 = 0;
                params.displayBladeAnomaliesAvg.L0 = 0; params.displayBladeAnomaliesAvg.L1 = 0;
            }
            updateInfoDisplay();
        }
        function applyHNMOutputsAndDirectControlToEntities() {
            let vineActionsToApply = ruleBasedActions.vine; player.vineControlledBy = "Rules (Current Intent)";

            if (playerDefeatedAndGameOver) {
                 // Vine becomes limp
            } else if (player.health > 0 && userInput.isDirectControllingVine && userInput.directControlActionActive) {
                vineActionsToApply = ruleBasedActions.vine; player.vineControlledBy = "DirectPlayer (BCI)";
            } else if (params.enableHNM && hnmPredictedActions.vine && !playerDefeatedAndGameOver && !(allEnemiesDefeatedAndPlayerAlive && celebrationModeActive) ) {
                if (Math.random() * 100 < params.hnmTakesControlChance) {
                    vineActionsToApply = hnmPredictedActions.vine; player.vineControlledBy = `HNM (${params.hnmTakesControlChance}%)`;
                } else {
                    player.vineControlledBy = `Rules (HNM Roll Fail: ${100 - params.hnmTakesControlChance}%)`;
                }
            }

            if (vineActionsToApply && vine.segments.length > 0 && !playerDefeatedAndGameOver) {
                for (let i = 0; i < vine.segments.length; i++) {
                    const seg = vine.segments[i];
                    const actionStartIndex = i * VINE_RULE_ACTION_DIM_PER_SEGMENT;
                    if (vineActionsToApply.length > actionStartIndex + 2 && seg.rigidBody) {
                        seg.rigidBody.resetForces(true);
                        seg.rigidBody.addForce({
                            x: vineActionsToApply[actionStartIndex] * params.vineForceScale,
                            y: vineActionsToApply[actionStartIndex + 1] * params.vineForceScale,
                            z: vineActionsToApply[actionStartIndex + 2] * params.vineForceScale
                        }, true);
                    }
                }
            } else if (playerDefeatedAndGameOver && vine.segments.length > 0) {
                 vine.segments.forEach(seg => { if (seg.rigidBody) seg.rigidBody.resetForces(true); });
            }


            blades.forEach((blade, index) => {
                if (blade.isStored || !blade.rigidBody) {
                    blade.controlledBy = "Stored"; return;
                }
                blade.rigidBody.resetForces(true); blade.rigidBody.resetTorques(true);

                if (blade.state.mode === "INERT" || playerDefeatedAndGameOver) {
                    blade.controlledBy = playerDefeatedAndGameOver ? "Inert (PlayerKO)" : "Inert (PostCelebration)";
                    return;
                }

                let bladeActionsToApply = ruleBasedActions.blades[index];
                blade.controlledBy = "Rules (Current Intent)";
                if (params.enableHNM && hnmPredictedActions.blades && hnmPredictedActions.blades[index] && !playerDefeatedAndGameOver && !(allEnemiesDefeatedAndPlayerAlive && celebrationModeActive)) {
                    if (Math.random() * 100 < params.hnmTakesControlChance) {
                        bladeActionsToApply = hnmPredictedActions.blades[index];
                        blade.controlledBy = `HNM (${params.hnmTakesControlChance}%)`;
                    } else {
                        blade.controlledBy = `Rules (HNM Roll Fail: ${100 - params.hnmTakesControlChance}%)`;
                    }
                }

                if (bladeActionsToApply && bladeActionsToApply.length === BLADE_RULE_ACTION_DIM) {
                    blade.rigidBody.addForce({
                        x: bladeActionsToApply[0] * params.bladeForceScale,
                        y: bladeActionsToApply[1] * params.bladeForceScale,
                        z: bladeActionsToApply[2] * params.bladeForceScale
                    }, true);
                    blade.rigidBody.addTorque({
                        x: bladeActionsToApply[3] * params.bladeTorqueScale,
                        y: bladeActionsToApply[4] * params.bladeTorqueScale,
                        z: bladeActionsToApply[5] * params.bladeTorqueScale
                    }, true);
                }
            });
        }

        function deployBlades(countToDeploy) {
            if (!world || !player || !player.rigidBody || playerDefeatedAndGameOver || (allEnemiesDefeatedAndPlayerAlive && celebrationModeActive) ) return;
            if (userInput.bciCoherence < params.bciCoherenceBladeDeployThreshold && params.autoBattleInfluence < 50 && player.health > 0) {
                updateInfoDisplay(`Blade deploy failed: Coherence ${userInput.bciCoherence.toFixed(2)} too low (Min: ${params.bciCoherenceBladeDeployThreshold})`);
                return;
            }
            let deployedCount = 0; const playerPos = player.rigidBody.translation(); const playerRot = player.rigidBody.rotation(); const playerThreeQuat = new THREE.Quaternion(playerRot.x, playerRot.y, playerRot.z, playerRot.w);
            for (let i = 0; i < blades.length && deployedCount < countToDeploy; i++) { const blade = blades[i]; if (blade.isStored) { const angleOffset = (Math.PI * 2 / params.numBlades) * i; const spawnOffsetLocal = new THREE.Vector3( Math.cos(angleOffset) * (params.bladeOrbitRadiusBase * 0.5), 0.3, Math.sin(angleOffset) * (params.bladeOrbitRadiusBase * 0.5) ); const spawnPosThree = spawnOffsetLocal.applyQuaternion(playerThreeQuat).add(new THREE.Vector3(playerPos.x,playerPos.y,playerPos.z));
                const bladeBodyDesc = RAPIER.RigidBodyDesc.dynamic().setTranslation(spawnPosThree.x, spawnPosThree.y, spawnPosThree.z).setCanSleep(false).setGravityScale(0.02).setLinearDamping(0.6).setAngularDamping(0.8); blade.rigidBody = world.createRigidBody(bladeBodyDesc); blade.collider = world.createCollider(RAPIER.ColliderDesc.cuboid(0.35, 0.04, 0.075).setDensity(0.2).setFriction(0.5).setRestitution(0.3), blade.rigidBody); blade.collider.setActiveEvents(RAPIER.ActiveEvents.COLLISION_EVENTS); blade.rigidBody.userData = {entityType: "blade", entityId: blade.id};
                blade.mesh.position.copy(spawnPosThree); blade.mesh.quaternion.copy(playerThreeQuat); blade.mesh.visible = true; blade.isStored = false;
                blade.state = { mode: 'ORBITING', currentTargetInfo: null, backupTimer: 0, aggressivePursuitTimer: 0, stuckTimer: 0, noTargetTimer: 0 };

                if (blade.hnm && blade.hnm.system && !blade.hnm.system.isDisposed) { blade.hnm.memoryState.forEach(s => window.disposeMemStateWeights(s)); blade.hnm.memoryState = blade.hnm.system.getInitialStates(); Object.values(blade.hnm.lastStepOutputs).forEach(valObj => { if(valObj?.retrievedVal && !valObj.retrievedVal.isDisposed) valObj.retrievedVal.dispose();}); blade.hnm.system.levelConfigsOriginal.forEach(lc => { blade.hnm.lastStepOutputs[lc.name] = { retrievedVal: tf.keep(tf.zeros([1, 1, lc.dim])) }; }); } else { console.warn(`Blade ${blade.id} HNM system is invalid or disposed during deployment. State not reset.`); } deployedCount++; } }
            if(deployedCount > 0) updateInfoDisplay(`${deployedCount} Blade(s) Deployed.`); else updateInfoDisplay("No stored blades to deploy.");
        }
        function recallAllBladesFunction(specificBladeIdToRecall = null) {
            let recalledCount = 0;
            blades.forEach(blade => {
                if ((specificBladeIdToRecall === null || blade.id === specificBladeIdToRecall) &&
                    !blade.isStored && blade.rigidBody) {
                    world.removeRigidBody(blade.rigidBody);
                    blade.rigidBody = null;
                    blade.collider = null;
                    blade.mesh.visible = false;
                    blade.isStored = true;
                    blade.state.mode = "STORED";
                    recalledCount++;
                }
            });
            if (specificBladeIdToRecall && recalledCount > 0) { updateInfoDisplay(`Blade ${specificBladeIdToRecall} Recalled.`); }
            else if (!specificBladeIdToRecall && recalledCount > 0) { updateInfoDisplay(`${recalledCount} Blade(s) Manually Recalled.`); }
            else if (!specificBladeIdToRecall) { updateInfoDisplay("No active blades to manually recall."); }
        }

        function updateInfoDisplay(message = "") {
            const activeBlades = blades.filter(b => !b.isStored).length;
            let statusText = `BCI Coherence: ${userInput.bciCoherence.toFixed(2)} | Blades: ${activeBlades}/${params.numBlades}<br/>`;
            let vineControlModeInfo = player.vineControlledBy || (userInput.isDirectControllingVine ? "DirectPlayer" : (params.enableHNM ? (params.hnmTakesControlChance > 0 ? `Rules/HNM (${params.hnmTakesControlChance}%)` : "HNM (Likely Rules)") : "Rules"));
            statusText += `Vine Ctrl: ${vineControlModeInfo} | Vine Action: ${userInput.bciCoherence > 0.4 && userInput.bciAction && !userInput.isDirectControllingVine ? "Manipulator" : (userInput.isDirectControllingVine && userInput.directControlActionActive ? "Direct" : "Armor")}<br/>`;
            let avgBladeControl = "Rules"; if (params.enableHNM && activeBlades > 0) { const hnmControlledBlades = blades.filter(b => !b.isStored && b.controlledBy && b.controlledBy.startsWith("HNM")).length; if (hnmControlledBlades > 0) avgBladeControl = `HNM (${Math.round(hnmControlledBlades/activeBlades*100)}%) / Rules`; else if (params.hnmTakesControlChance > 0) avgBladeControl = `Rules/HNM (${params.hnmTakesControlChance}%)`; else avgBladeControl = `HNM (Likely Rules)`; } statusText += `Blades Ctrl: ${activeBlades > 0 ? avgBladeControl : "N/A"}<br/>`
            statusText += `Player Health: ${player.health !== undefined ? Math.round(player.health) : 'N/A'}/${PLAYER_MAX_HEALTH} | Enemies Left: ${enemies.filter(e => e.health > 0).length}/${params.numEnemies}<br/>`;
            statusText += `Intent Source: Player ${(100 - params.autoBattleInfluence).toFixed(0)}% / Auto-Battle AI ${params.autoBattleInfluence.toFixed(0)}%<br/>`
            statusText += `Vine Anom: L0=${params.displayVineAnomalies.L0.toFixed(3)}, L1=${params.displayVineAnomalies.L1.toFixed(3)} | Blade Anom Avg: L0=${params.displayBladeAnomaliesAvg.L0.toFixed(3)}, L1=${params.displayBladeAnomaliesAvg.L1.toFixed(3)}<br/>`;
            statusText += `Desktop: WASD/Space + Mouse. BCI Aim: Hold Shift. BCI Action: Hold Ctrl+Click (while Shift held). VineDirect: V. Blades: 1 (Deploy), R (Recall).<br/>`; statusText += `Mobile: On-screen controls. BCI Aim: Hold 'BCIAim', BCI Act: Tap 'BCIAct'.`;
            if (playerDefeatedAndGameOver) statusText += `<br/><strong style="color:red;">GAME OVER - Player Defeated! Restarting soon...</strong>`;
            else if (allEnemiesDefeatedAndPlayerAlive) statusText += `<br/><strong style="color:lightgreen;">VICTORY! All Enemies Defeated! ${celebrationModeActive ? "Celebrating..." : "Restarting soon..."}</strong>`;
            else if (message) statusText += `<br/><i style="color:#ffffaa;">${message}</i>`; document.getElementById('info').innerHTML = statusText;
        }
        let lastFrameTime = performance.now();
        function animate() {
            requestAnimationFrame(animate); const time = performance.now(); const deltaTime = Math.min(0.05, (time - lastFrameTime) / 1000.0); lastFrameTime = time;

            playerDefeatedAndGameOver = gameOver && player.health <= 0;
            allEnemiesDefeatedAndPlayerAlive = gameOver && enemies.filter(e => e.health > 0).length === 0 && player.health > 0;

            if (allEnemiesDefeatedAndPlayerAlive && celebrationModeActive && time > celebrationEndTime) {
                celebrationModeActive = false;
                updateInfoDisplay("Celebration ended. Blades become inert. Restarting soon...");
                blades.forEach(blade => {
                    if (!blade.isStored && blade.rigidBody) {
                        blade.rigidBody.setGravityScale(1.0, true);
                        blade.state.mode = "INERT";
                    }
                });
                 setTimeout(() => initDemo(true), 2000);
            }


            updatePlayerPhysicsIntent();
            updateBCIAndHNMs(deltaTime);
            applyHNMOutputsAndDirectControlToEntities();
            updateEnemies(deltaTime);

            if(world) {
                world.step(eventQueue);
                eventQueue.drainCollisionEvents((handle1, handle2, started) => {
                    if (!started) return;
                    const col1 = world.getCollider(handle1); const col2 = world.getCollider(handle2);
                    if (!col1 || !col2) return;
                    const parentBody1 = col1.parent(); const parentBody2 = col2.parent();
                    const userData1 = parentBody1 ? parentBody1.userData : null; const userData2 = parentBody2 ? parentBody2.userData : null;

                    if (userData1 && userData1.entityType === "blade" && userData2 && userData2.entityType === "enemy") {
                        if (!allEnemiesDefeatedAndPlayerAlive && !playerDefeatedAndGameOver) {
                            const bladeBody = parentBody1; const bladeVelocity = bladeBody.linvel(); const speed = Math.sqrt(bladeVelocity.x**2 + bladeVelocity.y**2 + bladeVelocity.z**2);
                            const damageMultiplier = Math.max(0.5, Math.min(2.5, speed / 5.0)); const finalDamage = BLADE_HIT_DAMAGE * damageMultiplier;
                            handleEnemyDamage(userData2.entityId, finalDamage, userData1.entityId);
                        }
                    } else if (userData2 && userData2.entityType === "blade" && userData1 && userData1.entityType === "enemy") {
                         if (!allEnemiesDefeatedAndPlayerAlive && !playerDefeatedAndGameOver) {
                            const bladeBody = parentBody2; const bladeVelocity = bladeBody.linvel(); const speed = Math.sqrt(bladeVelocity.x**2 + bladeVelocity.y**2 + bladeVelocity.z**2);
                            const damageMultiplier = Math.max(0.5, Math.min(2.5, speed / 5.0)); const finalDamage = BLADE_HIT_DAMAGE * damageMultiplier;
                            handleEnemyDamage(userData1.entityId, finalDamage, userData2.entityId);
                        }
                    }
                    else if (userData1 && userData1.entityType === "enemy" && userData2 && userData2.entityType === "player") {
                        if (player.health > 0) {
                            const enemy = enemies.find(e => e.id === userData1.entityId);
                            if (enemy && enemy.attackCooldown <= 0) { handlePlayerDamage(enemy.damage, enemy.id); enemy.attackCooldown = 1.0 + Math.random() * 0.5; }
                        }
                    } else if (userData2 && userData2.entityType === "enemy" && userData1 && userData1.entityType === "player") {
                        if (player.health > 0) {
                            const enemy = enemies.find(e => e.id === userData2.entityId);
                            if (enemy && enemy.attackCooldown <= 0) { handlePlayerDamage(enemy.damage, enemy.id); enemy.attackCooldown = 1.0 + Math.random() * 0.5; }
                        }
                    }
                });
            }
            if (player?.mesh && player.rigidBody) { const playerPhysicsPos = player.rigidBody.translation(); player.mesh.position.set(playerPhysicsPos.x, playerPhysicsPos.y, playerPhysicsPos.z);
                if (!playerDefeatedAndGameOver) {
                    const camLookAtOffset = new THREE.Vector3(0, 0.8, 0);
                    const camLookAtTarget = new THREE.Vector3(playerPhysicsPos.x, playerPhysicsPos.y, playerPhysicsPos.z).add(camLookAtOffset);
                    const camDist = 5.5;
                    const camOffsetX = camDist * Math.sin(userInput.cameraYaw) * Math.cos(userInput.cameraPitch);
                    const camOffsetY = camDist * Math.sin(userInput.cameraPitch);
                    const camOffsetZ = camDist * Math.cos(userInput.cameraYaw) * Math.cos(userInput.cameraPitch);
                    camera.position.set(camLookAtTarget.x - camOffsetX, camLookAtTarget.y + camOffsetY, camLookAtTarget.z - camOffsetZ);
                    camera.lookAt(camLookAtTarget);
                }
            }
            vine?.segments.forEach(s => { if(s.mesh && s.rigidBody){const p=s.rigidBody.translation(); const q=s.rigidBody.rotation(); s.mesh.position.set(p.x,p.y,p.z); s.mesh.quaternion.set(q.x,q.y,q.z,q.w);}});
            blades.forEach(b => { if(!b.isStored && b.mesh && b.rigidBody){const p=b.rigidBody.translation(); const q=b.rigidBody.rotation(); b.mesh.position.set(p.x,p.y,p.z); b.mesh.quaternion.set(q.x,q.y,q.z,q.w);}});
            enemies.forEach(e => { if(e.health > 0 && e.mesh && e.rigidBody){const p=e.rigidBody.translation(); const q=e.rigidBody.rotation(); e.mesh.position.set(p.x,p.y,p.z); e.mesh.quaternion.set(q.x,q.y,q.z,q.w);}});
            const existingDebugLines = scene.getObjectByName("physicsDebugLines"); if (existingDebugLines) { scene.remove(existingDebugLines); if(existingDebugLines.geometry) existingDebugLines.geometry.dispose(); if(existingDebugLines.material) existingDebugLines.material.dispose(); } if (physicsLines && physicsLines !== existingDebugLines) { if(physicsLines.parent) scene.remove(physicsLines); if(physicsLines.geometry) physicsLines.geometry.dispose(); if(physicsLines.material) physicsLines.material.dispose(); } physicsLines = null;
            if (params.showRapierDebug && world) { const buffers = world.debugRender(); if (buffers && buffers.vertices && buffers.vertices.length > 0) { const geometry = new THREE.BufferGeometry(); geometry.setAttribute('position', new THREE.BufferAttribute(buffers.vertices, 3)); geometry.setAttribute('color', new THREE.BufferAttribute(buffers.colors, 4)); const material = new THREE.LineBasicMaterial({ vertexColors: true, depthTest:false, transparent:true, opacity:0.7 }); physicsLines = new THREE.LineSegments(geometry, material); physicsLines.name = "physicsDebugLines"; physicsLines.renderOrder = 999; scene.add(physicsLines); } }
            stats.update(); renderer.render(scene, camera);
        }
        main().catch(error => { console.error("Error initializing demo:", error); document.getElementById('info').textContent = "Error: " + error.message + ". Check console."; });
    </script>
</body>
</html>

